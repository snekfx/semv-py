#!/usr/bin/env bash
# Generated by build.sh on Mon Sep 22 04:01:54 PM MDT 2025
# Auto-assembled from numbered modules: 01_header.sh 02_colors.sh 03_printers.sh 04_options.sh 05_guards.sh 06_git-ops.sh 07_version.sh 08_detect.sh 09_resolve.sh 10_getset.sh 11_semver.sh 12_lifecycle.sh 13_commands.sh 14_hooks.sh 15_dispatch.sh
# === 01_header.sh ===
#!/usr/bin/env bash
#
# semv-config.sh - Configuration and Constants
# semv-version: 2.4.3
# 
# BashFX compliant configuration module
#

################################################################################
#
#  SEMV Configuration & Constants
#
################################################################################

# Self-reference variables
readonly SEMV_PATH="${BASH_SOURCE[0]}";
readonly SEMV_EXEC="$0";

# XDG+ Compliance paths (canonical *_HOME variables)
readonly SEMV_ETC_HOME="${XDG_ETC:-$HOME/.local/etc}/fx/semv";
readonly SEMV_DATA_HOME="${XDG_DATA:-$HOME/.local/data}/fx/semv";
readonly SEMV_LIB_HOME="${XDG_LIB:-$HOME/.local/lib}/fx/semv";

# Back-compatibility aliases
readonly SEMV_CONFIG="$SEMV_ETC_HOME";   # legacy naming
readonly SEMV_ETC="$SEMV_ETC_HOME";      # transitional alias
readonly SEMV_DATA="$SEMV_DATA_HOME";    # legacy naming

# RC file under ETC
readonly SEMV_RC="${SEMV_ETC_HOME}/.semv.rc";

# Commit message label conventions
# Commit label scheme (SEMV v2.0)
# Major:    major, breaking, api
# Minor:    feat, feature, add, minor
# Patch:    fix, patch, bug, hotfix, up
# Dev:      dev
readonly SEMV_MAJ_LABEL="(major|breaking|api)";
readonly SEMV_FEAT_LABEL="(feat|feature|add|minor)";  
readonly SEMV_FIX_LABEL="(fix|patch|bug|hotfix|up)";
readonly SEMV_DEV_LABEL="dev";

# Build system constants
readonly SEMV_MIN_BUILD=1000;     # Minimum build number floor

# Terminal setup
export TERM=xterm-256color;

SEMV_BUILD_FILE="semv.build"
BUILD_DIR="$PWD"

# Enable boxy integration if available
if command -v boxy >/dev/null 2>&1; then
    SEMV_USE_BOXY="1"
else
    SEMV_USE_BOXY="0"
fi

################################################################################
#
#  Semv Tool Version
#
################################################################################

# Application version (shown by --version / -v)
# Keep in sync with module semv-revision values
readonly SEMV_APP_VERSION="2.0.0";

################################################################################
#
#  Default Option States
#
################################################################################

# Standard BashFX flag variables (set by options())
opt_debug=0;       # 0=enabled, 1=disabled (default off=1)
opt_trace=1;       # 0=enabled, 1=disabled (default off=1)  
opt_quiet=0;       # 0=enabled, 1=disabled (default off=1 - show messages)
opt_force=0;       # 0=enabled, 1=disabled (default off=1)
opt_yes=0;         # 0=enabled, 1=disabled (default off=1)
opt_dev=0;         # 0=enabled, 1=disabled (default off=1)

# SEMV-specific option states
opt_dev_note=1;    # 0=enabled, 1=disabled (default off=1)
opt_build_dir="";   # Directory path for build output (empty = use current dir)
opt_no_cursor=1;   # 0=enabled, 1=disabled (default off=1)
opt_auto=0;        # 0=enabled (auto-mode default on to avoid prompts), 1=disabled
opt_help=1;        # 0=show help and exit, 1=normal
opt_version=1;     # 0=show version and exit, 1=normal
opt_dry_run=1;     # 0=dry run mode (show what would happen), 1=normal

################################################################################
#
#  Environment Variable Support
#
################################################################################

# Support NO_BUILD_CURSOR environment variable
if [[ "${NO_BUILD_CURSOR:-}" == "1" ]] || [[ "${NO_BUILD_CURSOR:-}" == "true" ]]; then
    opt_no_cursor=0;
fi

# Support QUIET_MODE, DEBUG_MODE, TRACE_MODE from BashFX standards (0=true)
if [[ -n "${QUIET_MODE+x}" ]]; then
    if [[ "${QUIET_MODE}" == "0" || "${QUIET_MODE}" == "true" ]]; then
        opt_quiet=0;
    else
        opt_quiet=1;
    fi
fi

if [[ -n "${DEBUG_MODE+x}" ]]; then
    if [[ "${DEBUG_MODE}" == "0" || "${DEBUG_MODE}" == "true" ]]; then
        opt_debug=0;
    else
        opt_debug=1;
    fi
fi

if [[ -n "${TRACE_MODE+x}" ]]; then
    if [[ "${TRACE_MODE}" == "0" || "${TRACE_MODE}" == "true" ]]; then
        opt_trace=0;
    else
        opt_trace=1;
    fi
fi

################################################################################
#
#  Configuration Validation
#
################################################################################

# Ensure XDG+ directories exist if we're in install mode
# (This will be called by lifecycle functions)
_ensure_xdg_paths() {
    local ret=1;
    
    ret=0;
    # Ensure ETC/DATA exist
    if [[ ! -d "$SEMV_ETC_HOME" ]]; then
        mkdir -p "$SEMV_ETC_HOME" 2>/dev/null || ret=1;
    fi
    
    if [[ ! -d "$SEMV_DATA_HOME" ]]; then
        mkdir -p "$SEMV_DATA_HOME" 2>/dev/null || ret=1;
    fi
    
    return "$ret";
}

# Mark config as loaded (load guard pattern)
readonly SEMV_CONFIG_LOADED=1;

# === 02_colors.sh ===
#
# semv-colors.sh - Color and Glyph Definitions  
# semv-revision: 2.0.0
# BashFX compliant color module using esc.sh standards
#

################################################################################
#
#  BashFX Standard Colors (from esc.sh)
#
################################################################################

# Core colors
readonly red=$'\x1B[38;5;197m';      # Was: $(tput setaf 202)
readonly green=$'\x1B[32m';          # Was: $(tput setaf 2)  
readonly blue=$'\x1B[36m';           # Was: $(tput setaf 12)
readonly orange=$'\x1B[38;5;214m';   # Was: $(tput setaf 214)
readonly yellow=$'\x1B[33m';         # Was: $(tput setaf 11)
readonly purple=$'\x1B[38;5;213m';   # Was: $(tput setaf 213)
readonly grey=$'\x1B[38;5;244m';     # Was: $(tput setaf 247)

# Extended colors
readonly blue2=$'\x1B[38;5;39m';
readonly cyan=$'\x1B[38;5;14m';
readonly white=$'\x1B[38;5;248m';
readonly white2=$'\x1B[38;5;15m';
readonly grey2=$'\x1B[38;5;240m';

# Control sequences
readonly revc=$'\x1B[7m';            # Reverse video - was: $(tput rev)
readonly bld=$'\x1B[1m';             # Bold
readonly x=$'\x1B[0m';               # Reset all attributes - was: $(tput sgr0)
readonly eol=$'\x1B[K';              # Erase to end of line

################################################################################
#
#  BashFX Standard Glyphs (from esc.sh)
#
################################################################################

# Status indicators
readonly pass=$'\u2713';             # âœ“ - was: "\xE2\x9C\x93"
readonly fail=$'\u2715';             # âœ• - was: "${red}\xE2\x9C\x97"  
readonly delta=$'\u25B3';            # â–³ - was: "\xE2\x96\xB3"
readonly star=$'\u2605';             # â˜… - was: "\xE2\x98\x85"

# Progress and activity  
readonly lambda=$'\u03BB';           # Î» - was: "\xCE\xBB"
readonly idots=$'\u2026';            # â€¦ - was: "\xE2\x80\xA6"
readonly bolt=$'\u21AF';             # â†¯ - was: "\xE2\x86\xAF"
readonly spark=$'\u27E1';            # âŸ¡ - was: "\xe2\x9f\xa1"

# Utility characters
readonly tab=$'\t';
readonly nl=$'\n';
readonly sp=' ';

################################################################################
#
#  SEMV-Specific Color Combinations
#
################################################################################

# Pre-composed colored glyphs for common patterns
readonly fail_red="${red}${fail}${x}";      # Red X for errors
readonly pass_green="${green}${pass}${x}";  # Green checkmark for success
readonly warn_orange="${orange}${delta}${x}"; # Orange triangle for warnings
readonly info_blue="${blue}${spark}${x}";   # Blue spark for info

################################################################################
#
#  Legacy Compatibility Mappings  
#
################################################################################

# Maintain compatibility with original semv variable names
# These can be removed in Phase 2 after function updates
readonly inv="$revc";                # Backwards compatibility for "inv"

# Mark colors as loaded (load guard pattern)
readonly SEMV_COLORS_LOADED=1;
# === 03_printers.sh ===
#
# semv-printers.sh - Output and Printing Functions
# semv-revision: 2.0.0 
# BashFX compliant printer module with predictable variables
#

################################################################################
#
#  Boxy Integration (Optional Enhancement)
#
################################################################################

# Boxy wrapper for enhanced visual output
boxy_msg() {
    local theme="$1";
    local message="$2";
    shift 2;
    
    if [[ "$SEMV_USE_BOXY" == "1" ]] && command_exists boxy; then
        echo "$message" | boxy --theme "$theme" "$@";
    else
        # Fallback to standard messaging
        case "$theme" in
            success) okay "$message" ;;
            error) error "$message" ;;
            warn) warn "$message" ;;
            info) info "$message" ;;
            *) info "$message" ;;
        esac
    fi
}

################################################################################
#
#  View Orchestration (Boxy Integration)
#
################################################################################

# view - Render content via boxy (if available) with a standard contract
# Arguments:
#   1: theme  - boxy theme (e.g., info, success, warn, error)
#   2: title  - title string
#   3: content - content to render (string)
#   4+: extra boxy flags (optional)
# Behavior:
#   - If --view=data, prints content only to stdout (no decorations)
#   - If boxy present and not in data mode, renders with boxy and prints to stderr
#   - Otherwise, prints simple fallback (title + content) to stderr
view() {
    local theme="$1"; shift || true
    local title="$1"; shift || true
    local content="$1"; shift || true
    local mode
    mode=$(get_view_mode)

    case "$mode" in
        data)
            # Data-only passthrough for ingestion/subcommands
            printf "%s\n" "$content"
            return 0
            ;;
        simple|full|*)
            if command_exists boxy; then
                printf "%b\n" "$content" | boxy --theme "${theme:-info}" --title "${title:-}" "$@"
            else
                # Fallback
                printf "%s%s%s\n" "$bld" "${title:-}" "$x" >&2
                printf "%b\n" "$content" >&2
            fi
            ;;
    esac
}

# view_status - Convenience renderer for status blocks
# Arguments:
#   1: content
# Uses theme=info, title="Repository Status"
view_status() {
    local content="$1"
    view info "Repository Status" "$content"
}

# view_dashboard - Enhanced dashboard renderer with visual dividers
# Arguments:
#   1: content
#   2: status_text (optional) - Text for the status line
# Uses theme=info, title with icon, and layout dividers for sections
view_dashboard() {
    local content="$1"
    local status_text="${2:-}"
    
    if [[ -n "$status_text" ]]; then
        # Use boxy status area with left alignment for pending actions
        view info "ðŸ“Š Repository Status" "$content" --layout dtn --status "sl:$status_text"
    else
        # Standard dashboard without status
        view info "ðŸ“Š Repository Status" "$content" --layout dtn
    fi
}

################################################################################
#
#  Drift View Orchestrator
#
################################################################################
# Arguments:
#   1: content - prepared content
#   2: state   - "drift" or "aligned" (optional)
# Behavior: Uses warn theme for drift, info for aligned

view_drift() {
    local content="$1"
    local state="${2:-aligned}"
    local theme="info"
    [[ "$state" == "drift" ]] && theme="warn"
    view "$theme" "Version Drift" "$content"
}

################################################################################
#
#  Core Printer Helper
#
################################################################################

__printf() {
    local text="$1";
    local color="${2:-white2}";
    local prefix="${!3:-}";
    local ret=1;
    
    if [[ -n "$text" ]]; then
        printf "${prefix}${!color}%b${x}" "$text" >&2;
        ret=0;
    fi
    
    return "$ret";
}

################################################################################
#
#  Standard BashFX Message Functions
#
################################################################################

# Info messages (silenced unless -d flag)
info() {
    local msg="$1";
    local force="${2:-1}";
    local ret=1;
    
    if [[ "$force" -eq 0 ]] || [[ "$opt_debug" -eq 0 ]]; then
        __printf "${info_blue} ${msg}\n" "blue";
        ret=0;
    fi
    
    return "$ret";
}

# Warning messages (silenced unless -d flag)  
warn() {
    local msg="$1";
    local force="${2:-1}";
    local ret=1;
    
    if [[ "$force" -eq 0 ]] || [[ "$opt_debug" -eq 0 ]]; then
        __printf "${warn_orange} ${msg}\n" "orange";
        ret=0;
    fi
    
    return "$ret";
}

# Success messages (silenced unless -d flag)
okay() {
    local msg="$1"; 
    local force="${2:-1}";
    local ret=1;
    
    if [[ "$force" -eq 0 ]] || [[ "$opt_debug" -eq 0 ]]; then
        __printf "${pass_green} ${msg}\n" "green";
        ret=0;
    fi
    
    return "$ret";
}

# Trace messages (silenced unless -t flag)
trace() {
    local msg="$1";
    local ret=1;
    
    if [[ "$opt_trace" -eq 0 ]]; then
        __printf "${idots} ${msg}\n" "grey";
        ret=0;
    fi
    
    return "$ret";
}

# Error messages (always visible unless -q flag)
error() {
    local msg="$1";
    local ret=1;
    
    if [[ "$opt_quiet" -eq 0 ]]; then
        __printf "${fail_red} ${msg}\n" "red";
        ret=0;
    fi
    
    return "$ret";
}

# Fatal errors (always visible, exits script)
fatal() {
    local msg="$1";
    local code="${2:-1}";
    
    trap - EXIT;
    __printf "\n${fail_red} ${msg}\n" "red";
    exit "$code";
}

################################################################################
#
#  User Interaction Functions
#
################################################################################

__confirm() {
    local prompt="$1";
    local ret=1;
    local answer;
    local src;
    
    # Auto-yes mode check
    if [[ "$opt_yes" -eq 0 ]]; then
        __printf "${bld}${green}auto yes${x}\n";
        return 0;
    fi
    
    __printf "${prompt}? > " "white2";
    
    # Determine input source: prefer tty when available
    if [[ -t 0 ]] && [[ -r "/dev/tty" ]]; then
        src="/dev/tty";
    else
        src="/dev/stdin";
    fi
    
    while read -r -n 1 -s answer < "$src"; do
        if [[ $? -eq 1 ]]; then
            exit 1;
        fi
        
        # Only accept valid responses
        if [[ ! "$answer" =~ [YyNn10tf+\-q] ]]; then
            continue;
        fi
        
        case "$answer" in
            [Yyt1+])
                __printf "${bld}${green}yes${x}";
                ret=0;
                ;;
            [Nnf0\-])
                __printf "${bld}${red}no${x}";
                ret=1;
                ;;
            [q])
                __printf "${bld}${purple}quit${x}\n";
                ret=1;
                exit 1;
                ;;
        esac
        break;
    done
    
    __printf "\n";
    return "$ret";
}

__prompt() {
    local msg="$1";
    local default="$2";
    local answer;
    
    if [[ "$opt_yes" -eq 1 ]]; then
        read -p "$msg --> " answer;
        if [[ -n "$answer" ]]; then
            echo "$answer";
        else
            echo "$default";
        fi
    else
        echo "$default";
    fi
}

################################################################################
#
#  Legacy Compatibility Functions
#
################################################################################

# Maintain backwards compatibility during migration
# These will be removed in Phase 2

identify() {
    local level="${#FUNCNAME[@]}";
    local f2="${FUNCNAME[2]}";
    
    if [[ "$opt_dev" -eq 0 ]]; then
        trace "âŸ¡â”€â”€â”€â”€[${white2}${FUNCNAME[1]}${grey}]${grey2}<-$f2";
    fi
}

################################################################################
#
#  View Mode Detection
#
################################################################################

get_view_mode() {
    local mode="${opt_view:-full}";
    [[ "$mode" =~ ^(data|simple|full)$ ]] && echo "$mode" || echo "full";
}

# Mark printers as loaded (load guard pattern)
readonly SEMV_PRINTERS_LOADED=1;

# === 04_options.sh ===
#
# semv-options.sh - Flag Parsing and Options
# semv-revision: 2.0.0
# BashFX compliant options module
#

################################################################################
#
#  options - Parse command-line flags and set opt_* variables
#
################################################################################
# Arguments: All command-line arguments ("$@")
# Returns: 0 on success, 1 on invalid flag
# Local Variables: this, next, opts, i
# Sets: opt_debug, opt_trace, opt_quiet, opt_force, opt_yes, opt_dev, etc.

options() {
    local this;
    local next;
    local opts=("$@");
    local i;
    local ret=0;

    for ((i=0; i<${#opts[@]}; i++)); do
        this="${opts[i]}";
        next="${opts[i+1]}";
        
        case "$this" in
            --help|-h)
                # Show help and exit
                opt_help=0;
                ;;
            --version|-v)
                # Show application version and exit
                opt_version=0;
                ;;
            --debug|-d)
                opt_debug=0;
                opt_quiet=1;
                ;;
            --trace|-t)
                opt_trace=0;
                opt_debug=0;
                ;;
            --quiet|-q)
                opt_quiet=0;
                opt_debug=1;
                opt_trace=1;
                ;;
            --force|-f)
                opt_force=0;
                ;;
            --yes|-y)
                opt_yes=0;
                ;;
            --dev|-D)
                # Master developer flag - enables debug and trace
                opt_dev=0;
                opt_debug=0;
                opt_trace=0;
                opt_quiet=1;
                ;;
            --dev-note|-N)
                opt_dev_note=0;
                ;;
            --dry-run)
                # Dry run mode - show what would happen without doing it
                opt_dry_run=0;
                ;;
            --build-dir=*)
                # Set build directory with = syntax
                opt_build_dir="${this#*=}";
                ;;
            --build-dir|-B)
                # Set build directory with next argument
                if [[ -n "$next" ]] && [[ ! "$next" =~ ^- ]]; then
                    opt_build_dir="$next";
                    ((i++));
                else
                    error "Missing directory argument for --build-dir";
                    ret=1;
                fi
                ;;
            --no-cursor)
                opt_no_cursor=0;
                ;;
            --auto)
                # Enable automation mode (silence ceremonies/prompts)
                opt_auto=0;
                ;;
            --no-auto)
                # Disable automation mode (allow ceremonies/prompts)
                opt_auto=1;
                ;;
            --view=*)
                # Set view mode (data/simple/full)
                opt_view="${this#*=}";
                ;;
            --view)
                # Set view mode with next argument
                if [[ -n "$next" ]] && [[ ! "$next" =~ ^- ]]; then
                    opt_view="$next";
                    ((i++));
                else
                    opt_view="simple";
                fi
                ;;
            -*)
                error "Invalid flag [$this]";
                ret=1;
                ;;
            *)
                # Non-flag arguments are passed through
                ;;
        esac
    done
    
    return "$ret";
}

################################################################################
#
#  _filter_args - Remove flags from argument list
#
################################################################################
# Arguments: All command-line arguments ("$@")
# Returns: 0 on success
# Local Variables: arg, filtered_args
# Outputs: Non-flag arguments to stdout

_filter_args() {
    local arg;
    local filtered_args=();
    local skip_next=false;
    
    for arg in "$@"; do
        if [[ "$skip_next" == true ]]; then
            skip_next=false;
            continue;
        fi
        
        case "$arg" in
            --build-dir|-B)
                # Skip this flag and the next argument (the directory path)
                skip_next=true;
                ;;
            --build-dir=*)
                # Skip this flag with embedded value
                ;;
            --view)
                # Skip this flag and the next argument (the view mode)
                skip_next=true;
                ;;
            --view=*)
                # Skip this flag with embedded value
                ;;
            -*)
                # Skip other flags
                ;;
            *)
                filtered_args+=("$arg");
                ;;
        esac
    done
    
    printf '%s\n' "${filtered_args[@]}";
    return 0;
}

# Mark options as loaded (load guard pattern)
readonly SEMV_OPTIONS_LOADED=1;

# === 05_guards.sh ===
#
# semv-guards.sh - Validation and State Check Functions
# semv-revision: 2.0.0
# BashFX compliant guard functions
#

################################################################################
#
#  Repository State Guards
#
################################################################################

################################################################################
#
#  is_repo - Check if current directory is a git repository
#
################################################################################
# Returns: 0 if git repo, 1 if not
# Local Variables: none

is_repo() {
    git rev-parse --is-inside-work-tree > /dev/null 2>&1;
}

################################################################################
#
#  is_main - Check if current branch is main/master
#
################################################################################
# Returns: 0 if on main/master branch, 1 if not
# Local Variables: branch, ret

is_main() {
    local branch;
    local ret=1;
    
    branch=$(this_branch);
    if [[ -n "$branch" ]] && [[ "$branch" == "main" || "$branch" == "master" ]]; then
        ret=0;
    fi
    
    return "$ret";
}

################################################################################
#
#  has_commits - Check if repository has any commits
#
################################################################################
# Returns: 0 if commits exist, 1 if not

has_commits() {
    local ret=1;
    
    if is_repo && git rev-parse HEAD > /dev/null 2>&1; then
        ret=0;
    fi
    
    return "$ret";
}

################################################################################
#
#  has_semver - Check if repository has semantic version tags
#
################################################################################
# Returns: 0 if semver tags exist, 1 if not

has_semver() {
    git tag --list | grep -qE 'v[0-9]+\.[0-9]+\.[0-9]+$';
}

################################################################################
#
#  is_not_staged - Check if working directory is clean
#
################################################################################
# Returns: 0 if clean, 1 if changes staged

is_not_staged() {
    git diff --exit-code > /dev/null 2>&1;
}

################################################################################
#
#  Development Mode Guards
#
################################################################################

################################################################################
#
#  is_dev - Check if development mode is enabled
#
################################################################################
# Returns: 0 if dev mode active, 1 if not

is_dev() {
    [[ "$opt_dev" -eq 0 ]] || [[ "${DEV_MODE:-}" == "1" ]];
}

################################################################################
#
#  is_quiet - Check if quiet mode is enabled
#
################################################################################
# Returns: 0 if quiet mode active, 1 if not

is_quiet() {
    [[ "$opt_quiet" -eq 0 ]] || [[ "${QUIET_MODE:-}" == "1" ]];
}

################################################################################
#
#  is_force - Check if force mode is enabled
#
################################################################################
# Returns: 0 if force mode active, 1 if not

is_force() {
    [[ "$opt_force" -eq 0 ]];
}

################################################################################
#
#  require_semv_baseline - Ensure repo has a baseline semver tag
#
################################################################################
# Returns: 0 if initialized, 1 otherwise (with guidance)

require_semv_baseline() {
    if has_semver; then
        return 0
    fi
    error "Repository not initialized for semv (no semver tags)"
    info "Run 'semv mark1' to establish a baseline from package version"
    info "Or 'semv new' to create v0.0.1 if no package version exists"
    return 1
}

################################################################################
#
#  Utility Guards
#
################################################################################

################################################################################
#
#  command_exists - Check if command is available
#
################################################################################
# Arguments:
#   1: cmd (string) - Command name to check
# Returns: 0 if command exists, 1 if not

command_exists() {
    local cmd="$1";
    type "$cmd" &> /dev/null;
}

################################################################################
#
#  function_exists - Check if function is defined
#
################################################################################
# Arguments:
#   1: func (string) - Function name to check
# Returns: 0 if function exists, 1 if not

function_exists() {
    local func="$1";
    [[ -n "$func" ]] && declare -F "$func" >/dev/null;
}

################################################################################
#
#  is_empty - Check if variable is empty or unset
#
################################################################################
# Arguments:
#   1: var (string) - Variable to check
# Returns: 0 if empty/unset, 1 if has value

is_empty() {
    local var="$1";
    [[ -z "$var" ]];
}

################################################################################
#
#  is_valid_semver - Check if string is valid semantic version
#
################################################################################
# Arguments:
#   1: version (string) - Version string to validate
# Returns: 0 if valid semver, 1 if not
# Local Variables: version

is_valid_semver() {
    local version="$1";
    [[ "$version" =~ ^v?([0-9]+)\.([0-9]+)\.([0-9]+)(-.+)?$ ]];
}

################################################################################
#
#  File System Guards
#
################################################################################

################################################################################
#
#  is_file - Check if path is a readable file
#
################################################################################
# Arguments:
#   1: path (string) - File path to check
# Returns: 0 if readable file, 1 if not

is_file() {
    local path="$1";
    [[ -f "$path" && -r "$path" ]];
}

################################################################################
#
#  is_dir - Check if path is a directory
#
################################################################################
# Arguments:
#   1: path (string) - Directory path to check
# Returns: 0 if directory exists, 1 if not

is_dir() {
    local path="$1";
    [[ -d "$path" ]];
}

################################################################################
#
#  is_writable - Check if path is writable
#
################################################################################
# Arguments:
#   1: path (string) - Path to check
# Returns: 0 if writable, 1 if not

is_writable() {
    local path="$1";
    [[ -w "$path" ]];
}

# Mark guards as loaded (load guard pattern)
readonly SEMV_GUARDS_LOADED=1;

# === 06_git-ops.sh ===
#
# semv-git-ops.sh - Git Operations and Repository Information
# semv-revision: 2.0.0
# BashFX compliant git operations module
#

################################################################################
#
#  Repository Information Functions
#
################################################################################

################################################################################
#
#  this_branch - Get current branch name
#
################################################################################
# Returns: 0 on success
# Outputs: Branch name to stdout

this_branch() {
    git branch --show-current;
}

################################################################################
#
#  this_user - Get git user name
#
################################################################################
# Returns: 0 on success
# Outputs: Git user name (spaces removed) to stdout

this_user() {
    git config user.name | tr -d ' ';
}

################################################################################
#
#  this_project - Get project name from git root
#
################################################################################
# Returns: 0 on success
# Outputs: Project directory name to stdout

this_project() {
    basename "$(git rev-parse --show-toplevel)";
}

################################################################################
#
#  which_main - Get main branch name from remote
#
################################################################################
# Returns: 0 on success, 1 if no commits
# Outputs: Main branch name to stdout

which_main() {
    local ret=1;
    
    if has_commits; then
        git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@';
        ret=0;
    fi
    
    return "$ret";
}

################################################################################
#
#  Commit Analysis Functions
#
################################################################################

################################################################################
#
#  last_commit - Get timestamp of last commit
#
################################################################################
# Returns: 0 if commits exist, 1 if none
# Outputs: Unix timestamp to stdout, "0" if no commits

last_commit() {
    local ret=1;
    
    if has_commits; then
        if git rev-parse HEAD >/dev/null 2>&1; then
            git show -s --format=%ct HEAD;
            ret=0;
        fi
    fi
    
    if [[ "$ret" -eq 1 ]]; then
        echo "0";
    fi
    
    return "$ret";
}

################################################################################
#
#  since_last - Count commit messages by label since tag
#
################################################################################
# Arguments:
#   1: tag (string) - Git tag to count from
#   2: label (string) - Commit message prefix to count
# Returns: 0 on success, 1 if not in repo
# Local Variables: tag, label, count
# Outputs: Number of matching commits to stdout

since_last() {
    local tag="$1";
    local label="$2";
    local count;
    local ret=1;

    if is_repo; then
        count=$(git log --pretty=format:"%s" "${tag}"..HEAD | grep -cE "^${label}:");
        echo "$count";
        trace "[$count] [$label] changes since [$tag]";
        ret=0;
    else
        error "Error. current dir not a git repo.";
    fi
    
    return "$ret";
}

################################################################################
#
#  Tag Operations
#
################################################################################

################################################################################
#
#  __git_list_tags - List all git tags
#
################################################################################
# Returns: 0 on success
# Outputs: All tags to stdout

__git_list_tags() {
    git show-ref --tags | cut -d '/' -f 3-;
}

################################################################################
#
#  __git_latest_tag - Get latest tag by version sort
#
################################################################################
# Returns: 0 if tags exist, 1 if none
# Local Variables: latest
# Outputs: Latest tag to stdout

__git_latest_tag() {
    local latest;
    local ret=1;
    
    if is_repo; then
        latest=$(git tag | sort -V | tail -n1);
        if [[ -n "$latest" ]]; then
            echo "$latest";
            ret=0;
        fi
    fi
    
    return "$ret";
}

################################################################################
#
#  __git_latest_semver - Get latest semantic version tag
#
################################################################################
# Returns: 0 if semver tags exist, 1 if none
# Local Variables: latest
# Outputs: Latest semver tag to stdout

__git_latest_semver() {
    local latest;
    local ret=1;
    
    if has_semver; then
        latest=$(git tag --list | grep -E 'v[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -n1);
        if [[ -n "$latest" ]]; then
            echo "$latest";
            ret=0;
        fi
    fi
    
    return "$ret";
}

################################################################################
#
#  __git_tag_create - Create annotated git tag
#
################################################################################
# Arguments:
#   1: tag (string) - Tag name to create
#   2: message (string) - Tag message
# Returns: 0 on success, 1 on failure
# Local Variables: tag, msg, ret

__git_tag_create() {
    local tag="$1";
    local msg="$2";
    local ret=1;
    
    if [[ -n "$tag" ]] && [[ -n "$msg" ]]; then
        git tag -a "$tag" -m "$msg";
        ret=$?;
    fi
    
    return "$ret";
}

################################################################################
#
#  __git_tag_delete - Delete git tag locally
#
################################################################################
# Arguments:
#   1: tag (string) - Tag name to delete
# Returns: 0 on success, 1 on failure

__git_tag_delete() {
    local tag="$1";
    local ret=1;
    
    if [[ -n "$tag" ]]; then
        if declare -F __tag_delete >/dev/null 2>&1; then
            __tag_delete "$tag";
            ret=$?;
        else
            git tag -d "$tag";
            ret=$?;
        fi
    fi
    
    return "$ret";
}

################################################################################
#
#  __git_push_tags - Push tags to remote
#
################################################################################
# Arguments:
#   1: force (optional) - Use --force if "force"
# Returns: 0 on success, 1 on failure
# Local Variables: force_flag, ret

__git_push_tags() {
    local force_flag="";
    local ret=1;
    
    if [[ "$1" == "force" ]]; then
        force_flag="--force";
    fi
    
    git push --tags $force_flag;
    ret=$?;
    
    return "$ret";
}

################################################################################
#
#  Build Information Functions
#
################################################################################

################################################################################
#
#  __git_build_count - Get commit count for build number
#
################################################################################
# Returns: 0 on success
# Local Variables: count
# Outputs: Build number to stdout

__git_build_count() {
    local count;
    
    count=$(git rev-list HEAD --count);
    count=$((count + SEMV_MIN_BUILD));
    echo "$count";
    return 0;
}

################################################################################
#
#  __git_remote_build_count - Get remote commit count
#
################################################################################
# Returns: 0 on success
# Local Variables: count
# Outputs: Remote build number to stdout

__git_remote_build_count() {
    local branch="";
    local ref="";
    local count_raw
    local count

    # Determine remote default branch using origin/HEAD if available
    branch=$(which_main 2>/dev/null || true)

    # Fallback: parse git remote show origin
    if [[ -z "$branch" ]]; then
        branch=$(git remote show origin 2>/dev/null | sed -n 's/.*HEAD branch: //p' | head -1)
    fi

    # Fallbacks to common names if remote HEAD not discoverable
    if [[ -z "$branch" ]]; then
        if git show-ref --verify --quiet refs/remotes/origin/main; then
            branch="main"
        elif git show-ref --verify --quiet refs/remotes/origin/master; then
            branch="master"
        else
            branch=""
        fi
    fi

    if [[ -n "$branch" ]]; then
        ref="origin/${branch}"
        count_raw=$(git rev-list "$ref" --count 2>/dev/null || echo 0)
    else
        count_raw=0
    fi

    # Normalize numeric and add floor
    count=$(( ${count_raw:-0} + SEMV_MIN_BUILD ))
    echo "$count"
    return 0;
}

################################################################################
#
#  Status and Analysis Functions
#
################################################################################

################################################################################
#
#  __git_status_count - Count changed files
#
################################################################################
# Returns: 0 on success
# Local Variables: count
# Outputs: Number of changed files to stdout

__git_status_count() {
    local count;
    
    count=$(git status --porcelain | wc -l | awk '{print $1}');
    echo "$count";
    return 0;
}

################################################################################
#
#  __git_fetch_tags - Fetch tags from remote
#
################################################################################
# Returns: git fetch return code
# Local Variables: before_fetch, after_fetch, output, ret

__git_fetch_tags() {
    local before_fetch;
    local after_fetch;
    local output;
    local ret;
    
    before_fetch=$(git tag);
    output=$(git fetch --tags 2>&1);
    ret=$?;
    after_fetch=$(git tag);
    
    if [[ "$before_fetch" != "$after_fetch" ]]; then
        okay "New tag changes found.";
    else
        info "No new tags.";
    fi
    
    return "$ret";
}

################################################################################
#
#  _latest_tag - Wrapper for do_latest_tag (compatibility)
#
################################################################################

_latest_tag() {
    do_latest_tag;
}

################################################################################
#
#  _is_git_repo - Check if current directory is a git repository
#
################################################################################

_is_git_repo() {
    git rev-parse --git-dir >/dev/null 2>&1;
}

# Mark git-ops as loaded (load guard pattern)
readonly SEMV_GIT_OPS_LOADED=1;

# === 07_version.sh ===
#
# semv-version.sh - Version Parsing and Comparison Logic
# semv-revision: 2.0.0
# BashFX compliant version handling with proper stream usage
#

################################################################################
#
#  Version Parsing Functions
#
################################################################################

################################################################################
#
#  split_vers - Parse semantic version string
#
################################################################################
# Arguments:
#   1: vers_str (string) - Version string to parse (e.g., "v1.2.3-dev_5")
# Returns: 0 on success, 1 on invalid format
# Local Variables: vers_str, ret
# Outputs: Space-separated version components to stdout
# Side Effects: Sets global vars major, minor, patch, extra

split_vers() {
    local vers_str="$1";
    local ret=1;
    
    if [[ -z "$vers_str" ]]; then
        return 1;
    fi
    
    if [[ $vers_str =~ ^v?([0-9]+)\.([0-9]+)\.([0-9]+)(-.+)?$ ]]; then
        major=${BASH_REMATCH[1]};
        minor=${BASH_REMATCH[2]};
        patch=${BASH_REMATCH[3]};
        extra=${BASH_REMATCH[4]};
        printf "%s %s %s %s\n" "$major" "$minor" "$patch" "$extra";
        ret=0;
    fi
    
    return "$ret";
}

################################################################################
#
#  _validate_version_format - Validate version string format
#
################################################################################
# Arguments:
#   1: version (string) - Version to validate
# Returns: 0 if valid, 1 if invalid
# Local Variables: version
# Stream Usage: No output (validation only)

_validate_version_format() {
    local version="$1";
    [[ "$version" =~ ^v?([0-9]+)\.([0-9]+)\.([0-9]+)(-.+)?$ ]];
}

################################################################################
#
#  Version Comparison Functions  
#
################################################################################

################################################################################
#
#  do_compare_versions - Compare two semantic versions
#
################################################################################
# Arguments:
#   1: version1 (string) - First version
#   2: operator (string) - Comparison operator (>, <, =, >=, <=, !=)
#   3: version2 (string) - Second version
# Returns: 0 if comparison true, 1 if false
# Local Variables: v1, op, v2, result
# Stream Usage: Messages to stderr, result to stdout

do_compare_versions() {
    local v1="$1";
    local op="$2"; 
    local v2="$3";
    local result;
    local ret=1;
    
    if [[ -z "$v1" ]] || [[ -z "$v2" ]] || [[ -z "$op" ]]; then
        error "Usage: do_compare_versions <version1> <operator> <version2>";
        return 1;
    fi
    
    # Validate version formats
    if ! _validate_version_format "$v1"; then
        error "Invalid version format: $v1";
        return 1;
    fi
    
    if ! _validate_version_format "$v2"; then
        error "Invalid version format: $v2";
        return 1;
    fi
    
    # Easy case: versions are identical
    if [[ "$v1" == "$v2" ]]; then
        case "$op" in
            '='|'=='|'>='|'<=') 
                printf "true\n";
                ret=0;
                ;;
            *) 
                printf "false\n";
                ret=1;
                ;;
        esac
        return "$ret";
    fi

    # Split versions into arrays using '.' as delimiter
    local OLD_IFS="$IFS";
    IFS='.';
    local -a ver1=($v1) ver2=($v2);
    IFS="$OLD_IFS";

    # Remove 'v' prefix if present
    ver1[0]=${ver1[0]#v};
    ver2[0]=${ver2[0]#v};

    # Find the longest version array to iterate through
    local i;
    local len1=${#ver1[@]};
    local len2=${#ver2[@]};
    local max_len=$(( len1 > len2 ? len1 : len2 ));

    # Compare each component numerically
    for ((i = 0; i < max_len; i++)); do
        # Pad missing components with 0
        local c1=${ver1[i]:-0};
        local c2=${ver2[i]:-0};
        
        # Remove any non-numeric suffixes for comparison
        c1=${c1%%-*};
        c2=${c2%%-*};

        if (( c1 > c2 )); then
            case "$op" in 
                '>'|'>='|'!=') 
                    printf "true\n";
                    ret=0;
                    ;;
                *) 
                    printf "false\n";
                    ret=1;
                    ;;
            esac
            return "$ret";
        fi
        
        if (( c1 < c2 )); then
            case "$op" in 
                '<'|'<='|'!=') 
                    printf "true\n";
                    ret=0;
                    ;;
                *) 
                    printf "false\n";
                    ret=1;
                    ;;
            esac
            return "$ret";
        fi
    done

    # If we get here, they are equal component-by-component
    case "$op" in 
        '='|'=='|'>='|'<=') 
            printf "true\n";
            ret=0;
            ;;
        *) 
            printf "false\n";
            ret=1;
            ;;
    esac
    
    return "$ret";
}

################################################################################
#
#  do_is_greater - Check if version B > version A
#
################################################################################
# Arguments:
#   1: version_b (string) - Version to test
#   2: version_a (string) - Version to compare against
# Returns: 0 if B > A, 1 otherwise
# Local Variables: result
# Stream Usage: Messages to stderr, no stdout

do_is_greater() {
    local version_b="$1";
    local version_a="$2";
    local result;
    local ret=1;
    
    if [[ -z "$version_a" ]] || [[ -z "$version_b" ]]; then
        error "Invalid comparison - missing version";
        return 1;
    fi
    
    trace "$version_b > $version_a ?";

    # Use comparison function
    result=$(do_compare_versions "$version_b" ">" "$version_a");
    if [[ "$result" == "true" ]]; then
        trace "$version_b > $version_a âœ“";
        ret=0;
    else
        trace "$version_b <= $version_a âœ—";
        ret=1;
    fi
    
    return "$ret";
}

################################################################################
#
#  Version Display Functions
#
################################################################################

################################################################################
#
#  do_test_semver - Test and display version parsing
#
################################################################################
# Arguments:
#   1: version (string) - Version to test
# Returns: 0 if valid, 1 if invalid
# Local Variables: version, parts, ret
# Stream Usage: Messages to stderr, parsed components to stdout

do_test_semver() {
    local version="$1";
    local parts;
    local ret=1;
    
    if [[ -z "$version" ]]; then
        error "Usage: do_test_semver <version>";
        return 1;
    fi
    
    info "Testing version format: $version";
    
    parts=$(split_vers "$version");
    ret=$?;
    
    if [[ "$ret" -eq 0 ]]; then
        local -a components=($parts);
        okay "Valid semantic version format";
        info "Major: ${components[0]}";
        info "Minor: ${components[1]}";  
        info "Patch: ${components[2]}";
        if [[ -n "${components[3]}" ]]; then
            info "Extra: ${components[3]}";
        fi
        printf "%s\n" "$parts";
    else
        error "Invalid semantic version format";
        error "Expected format: v1.2.3 or v1.2.3-suffix";
    fi
    
    return "$ret";
}

################################################################################
#
#  __version_greater - Compare two semantic versions
#
################################################################################
# Arguments:
#   1: version1 - First version (e.g., "1.2.3" or "v1.2.3")
#   2: version2 - Second version (e.g., "1.2.1" or "v1.2.1")  
# Returns: 0 if version1 > version2, 1 otherwise

__version_greater() {
    local v1="$1";
    local v2="$2";
    
    # Handle empty or invalid inputs
    if [[ -z "$v1" ]] || [[ -z "$v2" ]]; then
        return 1;
    fi
    
    # Remove v prefix if present
    v1="${v1#v}";
    v2="${v2#v}";
    
    # Split versions into arrays
    IFS='.' read -ra v1_parts <<< "$v1";
    IFS='.' read -ra v2_parts <<< "$v2";
    
    # Validate we have at least 3 parts (major.minor.patch)
    if [[ ${#v1_parts[@]} -lt 3 ]] || [[ ${#v2_parts[@]} -lt 3 ]]; then
        warn "Invalid version format for comparison: '$1' vs '$2'";
        return 1;
    fi
    
    # Compare major, minor, patch
    for i in {0..2}; do
        local p1="${v1_parts[i]:-0}";
        local p2="${v2_parts[i]:-0}";
        
        # Validate numeric values
        if ! [[ "$p1" =~ ^[0-9]+$ ]] || ! [[ "$p2" =~ ^[0-9]+$ ]]; then
            warn "Non-numeric version component: p1='$p1', p2='$p2'";
            return 1;
        fi
        
        if [[ "$p1" -gt "$p2" ]]; then
            return 0;  # v1 > v2
        elif [[ "$p1" -lt "$p2" ]]; then
            return 1;  # v1 < v2
        fi
        # If equal, continue to next part
    done
    
    return 1;  # versions are equal, so v1 is not > v2
}

################################################################################
#
#  __validate_semver - Validate semantic version format
#
################################################################################
# Arguments:
#   1: version - Version string to validate (e.g., "1.2.3" or "v1.2.3")
# Returns: 0 if valid semver, 1 if invalid

__validate_semver() {
    local version="$1";
    
    # Remove v prefix if present
    version="${version#v}";
    
    # Check format: X.Y.Z where X,Y,Z are numbers
    if [[ "$version" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        return 0;
    fi
    
    return 1;
}

# Mark version as loaded (load guard pattern)
readonly SEMV_VERSION_LOADED=1;
# === 08_detect.sh ===
#
# 08_detect.sh - Project Type Detection and Validation
# semv-revision: 2.0.0
# Part of SEMV - Semantic Version Manager
#

################################################################################
#
#  Project Detection Functions
#
################################################################################

################################################################################
#
#  detect_project_type - Identify project ecosystem(s) present
#
################################################################################
# Returns: 0 on success, 1 on failure or ambiguous project
# Local Variables: ret, found_types, type_count, bash_pattern
# Stream Usage: Messages to stderr, detected types to stdout

detect_project_type() {
    local ret=1;
    local -a found_types=();
    local type_count;
    local bash_pattern="";
    local manifest_detected=0;
    
    trace "Detecting project type...";
    
    # Check for Rust (Cargo.toml)
    if [[ -f "Cargo.toml" ]]; then
        if grep -q "^\[package\]" "Cargo.toml" 2>/dev/null; then
            found_types+=("rust");
            trace "Detected Rust project (Cargo.toml with [package])";
            manifest_detected=1;
        fi
    fi
    
    # Check for JavaScript/Node (package.json)
    if [[ -f "package.json" ]]; then
        if grep -q '"version"' "package.json" 2>/dev/null; then
            found_types+=("javascript");
            trace "Detected JavaScript project (package.json with version)";
            manifest_detected=1;
        fi
    fi
    
    # Check for Python (pyproject.toml or setup.py)
    if [[ -f "pyproject.toml" ]]; then
        if grep -q "^\[project\]" "pyproject.toml" 2>/dev/null; then
            found_types+=("python");
            trace "Detected Python project (pyproject.toml with [project])";
            manifest_detected=1;
        fi
    elif [[ -f "setup.py" ]]; then
        if grep -q "version=" "setup.py" 2>/dev/null; then
            found_types+=("python");
            trace "Detected Python project (setup.py with version)";
            manifest_detected=1;
        fi
    fi

    # Enhanced Bash project detection with pattern identification
    if [[ "$manifest_detected" -eq 0 ]]; then
        bash_pattern=$(detect_bash_project_pattern);
        if [[ -n "$bash_pattern" ]]; then
            found_types+=("bash");
            trace "Detected Bash project using pattern: $bash_pattern";
        fi
    else
        trace "Skipping bash detection due to manifest-based project discovery";
    fi
    
    type_count=${#found_types[@]};
    trace "Found $type_count project types: ${found_types[*]}";
    
    # Validate project structure
    case "$type_count" in
        0)
            error "No supported project types detected";
            info "Supported: Rust (Cargo.toml), JS (package.json), Python (pyproject.toml/setup.py), Bash (BashFX/scripts with version info)";
            return 1;
            ;;
        1)
            # Single project type - ideal
            printf "%s\n" "${found_types[0]}";
            ret=0;
            ;;
        *)
            # Multiple project types - check if they should sync
            if __should_sync_versions "${found_types[@]}"; then
                # Embedded packages - sync versions
                printf "%s\n" "${found_types[*]}";  # Space-separated list
                ret=0;
            else
                # Ambiguous project structure
                error "Multiple project types detected but they conflict";
                error "Found: ${found_types[*]}";
                error "Use single language per project or configure .semvrc for multi-language sync";
                return 1;
            fi
            ;;
    esac
    
    return "$ret";
}

################################################################################
#
#  detect_bash_project_pattern - Determine which bash project pattern is present
#
################################################################################
# Returns: 0 on success (pattern found), 1 on failure (no pattern found)
# Local Variables: folder_name, main_script
# Stream Usage: Pattern name to stdout, messages to stderr

detect_bash_project_pattern() {
    local folder_name;
    local main_script;
    local ret=1;
    
    folder_name=$(basename "$(pwd)");
    trace "Checking bash project patterns for folder: $folder_name";
    
    # Pattern 1: BashFX build.sh pattern (build.sh + parts/ + build.map)
    if [[ -f "build.sh" && -d "parts" ]]; then
        if [[ -f "parts/build.map" ]]; then
            # Full BashFX pattern with build.map
            local first_part;
            first_part=$(grep -v "^#" "parts/build.map" | grep -v "^$" | head -n1 | sed 's/.*:[[:space:]]*//' 2>/dev/null);
            if [[ -n "$first_part" && -f "parts/$first_part" ]]; then
                trace "Found first part from build.map: parts/$first_part";
                local version_found="";
                version_found=$(grep -E "^[[:space:]]*#[[:space:]]*(semv-version|version):" "parts/$first_part" 2>/dev/null);
                if [[ -n "$version_found" ]]; then
                    printf "bashfx-buildsh";
                    trace "Found BashFX build.sh pattern with version in parts/$first_part";
                    return 0;
                fi
            fi
        else
            # Has build.sh and parts/ but no build.map - still a build pattern
            local numbered_parts;
            numbered_parts=$(find parts -name "[0-9][0-9]_*.sh" -type f | sort | head -n1 2>/dev/null);
            if [[ -n "$numbered_parts" ]]; then
                local version_found="";
                version_found=$(grep -E "^[[:space:]]*#[[:space:]]*(semv-version|version):" "$numbered_parts" 2>/dev/null);
                if [[ -n "$version_found" ]]; then
                    printf "bashfx-buildsh";
                    trace "Found BashFX build.sh pattern (no build.map) with version in $numbered_parts";
                    return 0;
                fi
            fi
        fi
    fi
    
    # Pattern 2: BashFX simple pattern (prefix-name/ folder + name.sh file)
    if [[ "$folder_name" == *-* ]]; then
        local suffix="${folder_name##*-}";
        main_script="${suffix}.sh";
        if [[ -f "$main_script" ]]; then
            local version_found="";
            version_found=$(grep -E "^[[:space:]]*#[[:space:]]*(semv-version|version):" "$main_script" 2>/dev/null);
            if [[ -n "$version_found" ]]; then
                printf "bashfx-simple";
                trace "Found BashFX simple pattern: $folder_name -> $main_script with version";
                return 0;
            fi
        fi
    fi
    
    # Pattern 3: Standalone bash script (foldername.sh)
    main_script="${folder_name}.sh";
    if [[ -f "$main_script" ]]; then
        local version_found="";
        version_found=$(grep -E "^[[:space:]]*#[[:space:]]*(semv-version|version):" "$main_script" 2>/dev/null);
        if [[ -n "$version_found" ]]; then
            printf "bash-standalone";
            trace "Found standalone bash pattern: $main_script with version";
            return 0;
        fi
    fi
    
    # Pattern 4: Legacy semvrc configuration
    if [[ -f ".semvrc" ]]; then
        local bash_file;
        bash_file=$(grep "^BASH_VERSION_FILE=" ".semvrc" 2>/dev/null | cut -d'=' -f2 | tr -d '"'"'");
        if [[ -n "$bash_file" ]] && [[ -f "$bash_file" ]]; then
            local version_found="";
            version_found=$(grep -E "^[[:space:]]*#[[:space:]]*(semv-version|version):" "$bash_file" 2>/dev/null);
            if [[ -n "$version_found" ]]; then
                printf "bash-semvrc";
                trace "Found semvrc pattern: $bash_file with version";
                return 0;
            fi
        fi
    fi
    
    # Pattern 5: Generic version-commented bash files
    local bash_files;
    mapfile -t bash_files < <(find . -maxdepth 2 -name "*.sh" -type f 2>/dev/null)
    for file in "${bash_files[@]}"; do
        local version_found="";
        version_found=$(grep -E "^[[:space:]]*#[[:space:]]*(semv-version|version):" "$file" 2>/dev/null);
        if [[ -n "$version_found" ]]; then
            printf "bash-generic";
            trace "Found generic bash pattern: $file with version";
            return 0;
        fi
    done
    
    trace "No bash project pattern detected";
    return 1;
}

################################################################################
#
#  get_bash_project_file - Get the main version file for detected bash pattern
#
################################################################################
# Returns: 0 on success, 1 on failure
# Local Variables: pattern, folder_name, main_script, first_part
# Stream Usage: File path to stdout, messages to stderr

get_bash_project_file() {
    local pattern;
    local folder_name;
    local main_script;
    local first_part;
    local ret=1;
    
    pattern=$(detect_bash_project_pattern);
    if [[ -z "$pattern" ]]; then
        trace "No bash pattern detected, cannot determine project file";
        return 1;
    fi
    
    folder_name=$(basename "$(pwd)");
    
    case "$pattern" in
        bashfx-buildsh)
            # BashFX build.sh pattern - get first part file
            if [[ -f "parts/build.map" ]]; then
                first_part=$(grep -v "^#" "parts/build.map" | grep -v "^$" | head -n1 | sed 's/.*:[[:space:]]*//' 2>/dev/null);
                if [[ -n "$first_part" && -f "parts/$first_part" ]]; then
                    printf "parts/%s" "$first_part";
                    ret=0;
                fi
            else
                # No build.map, find first numbered part
                first_part=$(find parts -name "[0-9][0-9]_*.sh" -type f | sort | head -n1 2>/dev/null);
                if [[ -n "$first_part" ]]; then
                    printf "%s" "$first_part";
                    ret=0;
                fi
            fi
            ;;
        bashfx-simple)
            # BashFX simple pattern - prefix-name/name.sh
            local suffix="${folder_name##*-}";
            main_script="${suffix}.sh";
            if [[ -f "$main_script" ]]; then
                printf "%s" "$main_script";
                ret=0;
            fi
            ;;
        bash-standalone)
            # Standalone pattern - foldername.sh
            main_script="${folder_name}.sh";
            if [[ -f "$main_script" ]]; then
                printf "%s" "$main_script";
                ret=0;
            fi
            ;;
        bash-semvrc)
            # Legacy semvrc pattern
            local bash_file;
            bash_file=$(grep "^BASH_VERSION_FILE=" ".semvrc" 2>/dev/null | cut -d'=' -f2 | tr -d '"'"'");
            if [[ -n "$bash_file" && -f "$bash_file" ]]; then
                printf "%s" "$bash_file";
                ret=0;
            fi
            ;;
        bash-generic)
            # Generic pattern - first file with version comment
            local bash_files;
            mapfile -t bash_files < <(find . -maxdepth 2 -name "*.sh" -type f 2>/dev/null)
            for file in "${bash_files[@]}"; do
                if grep -q -E "^[[:space:]]*#[[:space:]]*(semv-version|version):" "$file" 2>/dev/null; then
                    printf "%s" "$file";
                    ret=0;
                    break;
                fi
            done
            ;;
        *)
            trace "Unknown bash pattern: $pattern";
            ;;
    esac
    
    return "$ret";
}

################################################################################
#
#  __should_sync_versions - Determine if multiple languages should sync versions
#
################################################################################
# Arguments: List of detected project types
# Returns: 0 if should sync, 1 if conflicting
# Local Variables: ret, has_conflict
# Stream Usage: Messages to stderr

__should_sync_versions() {
    local ret=1;
    local has_conflict=0;
    
    # For now, assume embedded packages should sync
    # Future: Check for submodule markers or .semvrc configuration
    
    # Check for obvious conflicts (future implementation)
    # - Different major versions across package files
    # - Presence of submodule indicators
    # - Explicit .semvrc configuration against syncing
    
    if [[ "$has_conflict" -eq 0 ]]; then
        trace "Multi-language project approved for version sync";
        ret=0;
    else
        trace "Multi-language project has version conflicts";
    fi
    
    return "$ret";
}

################################################################################
#
#  Version File Detection Functions
#
################################################################################

################################################################################
#
#  get_version_files - Get list of version-containing files for project type
#
################################################################################
# Arguments:
#   1: project_type - Type of project (rust, javascript, python, bash)
# Returns: 0 on success, 1 on failure
# Local Variables: project_type, ret
# Stream Usage: File paths to stdout, messages to stderr

get_version_files() {
    local project_type="$1";
    local ret=1;
    
    case "$project_type" in
        rust)
            if [[ -f "Cargo.toml" ]]; then
                printf "Cargo.toml\n";
                ret=0;
            fi
            ;;
        javascript)
            if [[ -f "package.json" ]]; then
                printf "package.json\n";
                ret=0;
            fi
            ;;
        python)
            if [[ -f "pyproject.toml" ]]; then
                printf "pyproject.toml\n";
                ret=0;
            elif [[ -f "setup.py" ]]; then
                printf "setup.py\n";
                ret=0;
            fi
            ;;
        bash)
            local bash_file;
            if [[ -f ".semvrc" ]]; then
                bash_file=$(grep "^BASH_VERSION_FILE=" ".semvrc" 2>/dev/null | cut -d'=' -f2 | tr -d '"'"'");
                if [[ -n "$bash_file" ]] && [[ -f "$bash_file" ]]; then
                    printf "%s\n" "$bash_file";
                    ret=0;
                fi
            else
                # Find first bash file with version comment
                local bash_files;
                mapfile -t bash_files < <(find . -maxdepth 2 -name "*.sh" -type f 2>/dev/null)
                for file in "${bash_files[@]}"; do
                    if grep -q "# semv-version:" "$file" 2>/dev/null || grep -q "# version:" "$file" 2>/dev/null; then
                        printf "%s\n" "$file";
                        ret=0;
                        break;
                    fi
                done
            fi
            ;;
        *)
            error "Unknown project type: $project_type";
            ;;
    esac
    
    return "$ret";
}

################################################################################
#
#  is_project_type - Check if current directory contains specified project type
#
################################################################################
# Arguments:
#   1: project_type - Type to check for
# Returns: 0 if project type present, 1 if not
# Local Variables: project_type
# Stream Usage: No output

is_project_type() {
    local project_type="$1";
    
    case "$project_type" in
        rust)
            [[ -f "Cargo.toml" ]] && grep -q "^\[package\]" "Cargo.toml" 2>/dev/null;
            ;;
        javascript)
            [[ -f "package.json" ]] && grep -q '"version"' "package.json" 2>/dev/null;
            ;;
        python)
            ([[ -f "pyproject.toml" ]] && grep -q "^\[project\]" "pyproject.toml" 2>/dev/null) || \
            ([[ -f "setup.py" ]] && grep -q "version=" "setup.py" 2>/dev/null);
            ;;
        bash)
            if [[ -f ".semvrc" ]]; then
                local bash_file;
                bash_file=$(grep "^BASH_VERSION_FILE=" ".semvrc" 2>/dev/null | cut -d'=' -f2 | tr -d '"'"'");
                [[ -n "$bash_file" ]] && [[ -f "$bash_file" ]] && \
                (grep -q "# semv-version:" "$bash_file" 2>/dev/null || grep -q "# version:" "$bash_file" 2>/dev/null);
            else
                local bash_files;
                mapfile -t bash_files < <(find . -maxdepth 2 -name "*.sh" -type f 2>/dev/null)
                for file in "${bash_files[@]}"; do
                    if grep -q "# semv-version:" "$file" 2>/dev/null || grep -q "# version:" "$file" 2>/dev/null; then
                        return 0;
                    fi
                done
                return 1;
            fi
            ;;
        *)
            return 1;
            ;;
    esac
}

# === 09_resolve.sh ===
#
# 09_resolve.sh - Version Resolution and Conflict Handling
# semv-revision: 2.0.0
# Part of SEMV - Semantic Version Manager
#

################################################################################
#
#  Version Resolution Functions  
#
################################################################################

################################################################################
#
#  resolve_version_conflicts - Main conflict resolution orchestrator
#
################################################################################
# Returns: 0 on successful resolution, 1 on unresolvable conflicts
# Local Variables: ret, project_types, package_version, git_version, semv_version
# Stream Usage: Messages to stderr

resolve_version_conflicts() {
    local source_file="${1:-}";
    local ret=1;
    local project_types;
    local package_version="";
    local git_version; 
    local semv_version;

    info "Analyzing version sources for conflicts...";

    # If a specific source file is provided, extract version from it directly
    if [[ -n "$source_file" ]]; then
        if [[ -f "$source_file" ]]; then
            package_version=$(__extract_version_from_file "$source_file");
            if [[ -z "$package_version" ]]; then
                warn "Could not extract version from: $source_file";
            else
                trace "Using provided source file version: $package_version ($source_file)";
            fi
        else
            warn "Source file not found: $source_file";
        fi
    fi

    # If no override version, fall back to auto detection of project types/files
    if [[ -z "$package_version" ]]; then
        if project_types=$(detect_project_type); then
            package_version=$(_get_package_version "$project_types");
        else
            # No supported project types found; continue with tags-only authority
            warn "No supported package files detected; using tags as authority";
        fi
    fi

    # Get tag and calculated versions
    git_version=$(_latest_tag);
    # Normalize git version to number (strip leading 'v') for potential comparisons
    local git_version_num="${git_version#v}";
    semv_version=$(_calculate_semv_version);

    trace "Package version: ${package_version:-none}";
    trace "Git tag version: ${git_version:-none}";
    trace "Calculated version: ${semv_version:-none}";

    # Analyze version relationships (highest wins policy handled inside)
    if ! _analyze_version_drift "$package_version" "$git_version" "$semv_version"; then
        error "Version analysis failed";
        return 1;
    fi

    ret=0;
    return "$ret";
}

################################################################################
#
#  _get_package_version - Extract version from package file(s)
#
################################################################################  
# Arguments:
#   1: project_types - Space-separated list of project types
# Returns: 0 on success, 1 on failure
# Local Variables: project_types, type, version, highest_version
# Stream Usage: Version string to stdout

_get_package_version() {
    local project_types="$1";
    local type;
    local version;
    local highest_version="";
    
    # Handle multiple project types by finding highest version
    for type in $project_types; do
        version=$(__get_single_package_version "$type");
        if [[ -n "$version" ]]; then
            if [[ -z "$highest_version" ]] || __version_greater "$version" "$highest_version"; then
                highest_version="$version";
            fi
        fi
    done
    
    if [[ -n "$highest_version" ]]; then
        printf "%s\n" "$highest_version";
        return 0;
    fi
    
    return 1;
}

################################################################################
#
#  __get_single_package_version - Extract version from single package file
#
################################################################################
# Arguments:
#   1: project_type - Single project type
# Returns: 0 on success, 1 on failure  
# Local Variables: project_type, version_file, version
# Stream Usage: Version string to stdout

__get_single_package_version() {
    local project_type="$1";
    local version_file;
    local version;
    
    version_file=$(get_version_files "$project_type");
    if [[ -z "$version_file" ]] || [[ ! -f "$version_file" ]]; then
        return 1;
    fi
    
    case "$project_type" in
        rust)
            # Extract: version = "1.2.3" from [package] section
            version=$(awk '
                /^\[package\]/ { in_package=1; next }
                /^\[/ { in_package=0; next }
                in_package && /^version\s*=/ {
                    gsub(/.*=\s*"/, "");
                    gsub(/".*/, "");
                    print;
                    exit;
                }
            ' "$version_file");
            ;;
        javascript)
            # Extract: "version": "1.2.3" from JSON
            version=$(grep '"version"' "$version_file" | head -1 | sed 's/.*"version"[[:space:]]*:[[:space:]]*"//;s/".*//')
            ;;
        python)
            if [[ "$version_file" == "pyproject.toml" ]]; then
                # Extract: version = "1.2.3" from [project] section  
                version=$(awk '
                    /^\[project\]/ { in_project=1; next }
                    /^\[/ { in_project=0; next }
                    in_project && /^version\s*=/ {
                        gsub(/.*=\s*"/, "");
                        gsub(/".*/, "");
                        print;
                        exit;
                    }
                ' "$version_file");
            else
                # Extract from setup.py - more complex parsing needed
                version=$(grep -o 'version[[:space:]]*=[[:space:]]*['"'"'"][^"'"'"']*['"'"'"]' "$version_file" | head -1 | sed 's/.*=[[:space:]]*['"'"'"]//' | sed 's/['"'"'"].*//');
            fi
            ;;
        bash)
            # Extract: # semv-version: 1.2.3 or # version: 1.2.3 (exclude code lines)
            version=$(grep -E "^[[:space:]]*#[[:space:]]*(semv-version|semv-revision|version):" "$version_file" | grep -v '\$\|"' | head -1 | sed 's/.*:[[:space:]]*//');
            # Clean up version (remove v prefix, whitespace, and trailing text after version)
            version=$(echo "$version" | sed 's/^v//;s/[[:space:]]*$//g' | awk '{print $1}');
            ;;
    esac
    
    if [[ -n "$version" ]]; then
        # Clean up version string (remove v prefix, whitespace)
        version=$(echo "$version" | sed 's/^v//;s/[[:space:]]*//g');
        printf "%s\n" "$version";
        return 0;
    fi
    
    return 1;
}

################################################################################
#
#  _calculate_semv_version - Calculate what semv thinks version should be
#
################################################################################
# Returns: 0 on success, 1 on failure
# Local Variables: latest_tag, commits_since, calculated_version
# Stream Usage: Version string to stdout

_calculate_semv_version() {
    local latest_tag;
    local commits_since;
    local calculated_version;
    
    latest_tag=$(_latest_tag);
    if [[ -z "$latest_tag" ]]; then
        # No tags yet - calculate from beginning
        calculated_version=$(do_next_semver);
    else
        # Calculate next version (do_next_semver gets latest tag itself)
        calculated_version=$(do_next_semver);
    fi
    
    if [[ -n "$calculated_version" ]]; then
        printf "%s\n" "$calculated_version";
        return 0;
    fi
    
    return 1;
}

################################################################################
#
#  _analyze_version_drift - Analyze version relationships and resolve conflicts
#
################################################################################
# Arguments:
#   1: package_version - Version from package files
#   2: git_version - Latest git tag version
#   3: semv_version - Calculated semv version  
# Returns: 0 on successful analysis, 1 on failure
# Local Variables: package_version, git_version, semv_version, resolution

_analyze_version_drift() {
    local package_version="$1";
    local git_version="$2"; 
    local semv_version="$3";
    local resolution;
    
    # Handle missing versions
    if [[ -z "$package_version" ]] && [[ -z "$git_version" ]]; then
        info "No existing versions found - proceeding with semv calculation";
        return 0;
    fi
    
    if [[ -z "$package_version" ]]; then
        info "No package version found - using git tags as authority";
        return 0;
    fi
    
    if [[ -z "$git_version" ]]; then
        warn "No git tags found - package version will be used as baseline";
        if ! __create_sync_tag "$package_version"; then
            error "Failed to create sync tag for package version";
            return 1;
        fi
        return 0;
    fi
    
    # Compare versions and determine resolution strategy
    if __version_greater "$package_version" "$git_version"; then
        if __version_greater "$package_version" "$semv_version"; then
            # Package version is highest - semv is behind
            resolution="package_ahead";
        else
            # Package > git, but semv > package (semv got happy)
            resolution="semv_happy";  
        fi
    elif __version_greater "$git_version" "$package_version"; then
        # Git version is higher - package is stale
        resolution="package_stale";
    else
        # Versions are equal
        if __version_greater "$semv_version" "$package_version"; then
            # All equal but semv calculated higher
            resolution="semv_calculated_ahead";
        else
            resolution="versions_aligned";
        fi
    fi
    
    trace "Resolution strategy: $resolution";
    
    # Execute resolution strategy
    case "$resolution" in
        package_ahead)
            __handle_package_ahead "$package_version" "$git_version";
            ;;
        semv_happy)
            __handle_semv_happy "$package_version" "$semv_version";  
            ;;
        package_stale)
            __handle_package_stale "$package_version" "$git_version";
            ;;
        semv_calculated_ahead)
            __handle_semv_calculated_ahead "$source_file" "$semv_version";
            ;;
        versions_aligned)
            info "All version sources aligned - proceeding normally";
            ;;
        *)
            error "Unknown resolution strategy: $resolution";
            return 1;
            ;;
    esac
    
    return 0;
}

################################################################################
#
#  Resolution Strategy Handlers
#
################################################################################

################################################################################
#
#  __handle_package_ahead - Package version higher than git tags
#
################################################################################
# Arguments:
#   1: package_version - Version from package files
#   2: git_version - Version from git tags
# Returns: 0 on success, 1 on failure

__handle_package_ahead() {
    local package_version="$1";
    local git_version="$2";
    
    warn "Version drift detected:";
    warn "  Package version: $package_version";
    warn "  Git tag version: ${git_version:-none}";
    warn "  Semv is behind authoritative package version";
    
    # Check for auto-resolution
    if [[ "$opt_auto" -eq 0 ]]; then
        info "Auto-resolving: creating sync tag for $package_version";
    else
        if ! __confirm "Create sync tag at $package_version to align semv"; then
            error "Version sync cancelled by user";
            return 1;
        fi
    fi
    
    # Create sync tag
    if ! __create_sync_tag "$package_version"; then
        error "Failed to create sync tag";
        return 1;
    fi
    
    # Offer catch-up for minor/patch versions
    __offer_version_catchup "$package_version";
    
    return 0;
}

################################################################################
#
#  __handle_semv_happy - Semv calculated version higher than authoritative sources
#
################################################################################  
# Arguments:
#   1: package_version - Authoritative package version
#   2: semv_version - Over-calculated semv version
# Returns: 0 on success

__handle_semv_happy() {
    local package_version="$1";
    local semv_version="$2";
    
    warn "Semv over-calculation detected:";
    warn "  Package version: $package_version (authoritative)";
    warn "  Semv calculated: $semv_version";
    warn "  Deferring to authoritative package version";
    
    # Create sync tag at package version  
    if ! __create_sync_tag "$package_version"; then
        error "Failed to create authoritative sync tag";
        return 1;
    fi
    
    info "Semv will now count from $package_version baseline";
    return 0;
}

################################################################################
#
#  __handle_semv_calculated_ahead - Calculated version ahead of package/git
#
################################################################################
# Arguments:
#   1: source_file - Package file to update
#   2: semv_version - Calculated semv version to sync to
# Returns: 0 on success, 1 on failure

__handle_semv_calculated_ahead() {
    local source_file="$1";
    local semv_version="$2";
    
    info "Semv calculated version ahead - proceeding with bump";
    info "  Target version: $semv_version";
    
    # Update package version to match calculated semv
    if [[ -n "$source_file" && -f "$source_file" ]]; then
        if ! __update_package_version_with_details "$source_file" "$semv_version"; then
            error "Failed to update package version";
            return 1;
        fi
    fi
    
    # Create git tag for the new version
    if ! __create_sync_tag "$semv_version"; then
        error "Failed to create sync tag";
        return 1;
    fi
    
    return 0;
}

################################################################################
#
#  __handle_package_stale - Package version lower than git tags
#
################################################################################
# Arguments:
#   1: package_version - Stale package version
#   2: git_version - Current git tag version  
# Returns: 0 on success, 1 on failure

__handle_package_stale() {
    local package_version="$1";
    local git_version="$2";
    
    warn "Stale package file detected:";
    warn "  Package version: $package_version";
    warn "  Git tag version: $git_version";
    warn "  Package file needs updating";
    
    if [[ "$opt_auto" -eq 0 ]]; then
        info "Auto-updating package file to $git_version";
        __update_package_version_with_details "$package_version" "$git_version";
    else
        if __confirm "Update package file to match git tag ($git_version)"; then
            __update_package_version_with_details "$package_version" "$git_version";
        else
            warn "Package file not updated - may cause further conflicts";
        fi
    fi
    
    return 0;
}

################################################################################
#
#  Utility Functions
#
################################################################################

################################################################################
#
#  __create_sync_tag - Create synchronization tag at specified version
#
################################################################################
# Arguments:
#   1: version - Version to tag (without v prefix)
# Returns: 0 on success, 1 on failure

__create_sync_tag() {
    local version="$1";
    local tag_name;
    
    # Ensure single 'v' prefix (handle both v1.2.3 and 1.2.3 inputs)
    if [[ "$version" =~ ^v ]]; then
        tag_name="$version";
    else
        tag_name="v${version}";
    fi
    
    if ! _is_git_repo; then
        error "Not in git repository - cannot create sync tag";
        return 1;
    fi
    
    trace "Creating sync tag: $tag_name";
    
    # Show what we're creating using boxy integration
    local tag_info="Creating sync tag: ${tag_name}\nMessage: semv sync alignment";
    view "info" "ðŸ·ï¸ Git Tag Creation" "$tag_info";
    
    if git tag -a "$tag_name" -m "semv sync: align to package version $version" 2>/dev/null; then
        okay "âœ“ Created sync tag: $tag_name";
        return 0;
    else
        error "âœ— Failed to create sync tag: $tag_name";
        return 1;
    fi
}

################################################################################
#
#  __offer_version_catchup - Offer to catch up minor/patch versions
#
################################################################################
# Arguments:
#   1: base_version - Base version to catch up from
# Returns: 0 always (non-critical)

__offer_version_catchup() {
    local base_version="$1";
    
    # Check environment safety flags
    if [[ "${SEMV_ALL_AUTO_SAFE:-}" == "1" ]]; then
        trace "Auto-catchup disabled by SEMV_ALL_AUTO_SAFE";
        return 0;
    fi
    
    # For now, just inform user - full implementation in Phase 5
    info "Catch-up functionality will be available in future release";
    info "You can manually bump versions as needed from $base_version baseline";
    
    return 0;
}

################################################################################
#
#  __extract_version_from_file - Extract version from a specific file path
#
################################################################################
# Arguments:
#   1: file_path - Path to file containing a version
# Returns: 0 on success, 1 on failure
# Stream Usage: Version (without leading 'v') to stdout

__extract_version_from_file() {
    local file_path="$1";
    local version="";

    if [[ ! -f "$file_path" ]]; then
        return 1;
    fi

    case "$file_path" in
        *package.json)
            version=$(grep -m1 '"version"' "$file_path" | sed 's/.*"version"[[:space:]]*:[[:space:]]*"//;s/".*//');
            ;;
        *pyproject.toml)
            version=$(awk '
                /^\[project\]/ { in_project=1; next }
                /^\[/ { in_project=0; next }
                in_project && /^version\s*=/ {
                    gsub(/.*=\s*"/, "");
                    gsub(/".*/, "");
                    print; exit;
                }
            ' "$file_path");
            ;;
        *setup.py)
            version=$(grep -o 'version[[:space:]]*=[[:space:]]*["'\'''][^"'\''']*["'\''']' "$file_path" | head -1 | sed 's/.*=[[:space:]]*["'\''']//; s/["'\''].*$//');
            ;;
        *Cargo.toml)
            version=$(awk '
                /^\[package\]/ { in_package=1; next }
                /^\[/ { in_package=0; next }
                in_package && /^version\s*=/ {
                    gsub(/.*=\s*"/, "");
                    gsub(/".*/, "");
                    print; exit;
                }
            ' "$file_path");
            ;;
        *.sh|*)
            # Default: try bash-style version comments near header
            version=$(grep -E "^[[:space:]]*#[[:space:]]*(semv-version|semv-revision|version):" "$file_path" | grep -v '\$\|"' | head -1 | sed 's/.*:[[:space:]]*//');
            ;;
    esac

    if [[ -n "$version" ]]; then
        version=$(echo "$version" | sed 's/^v//;s/[[:space:]]*$//g' | awk '{print $1}')
        printf "%s\n" "$version";
        return 0;
    fi

    return 1;
}

################################################################################
#
#  __update_package_version - Update version in package file(s)
#
################################################################################
# Arguments:
#   1: new_version - Version to set (without v prefix)
# Returns: 0 on success, 1 on failure

__update_package_version() {
    local new_version="$1";
    
    # Connect to existing set command functionality
    local project_types;
    if project_types=$(detect_project_type); then
        case "$project_types" in
            rust)
                do_set rust "$new_version";;
            javascript)  
                do_set js "$new_version";;
            python)
                do_set python "$new_version";;
            bash)
                local bash_file;
                # Use intelligent pattern detection first
                bash_file=$(get_bash_project_file);
                if [[ -z "$bash_file" ]]; then
                    # Fallback to legacy detection
                    bash_file=$(detect_bash_version_file);
                fi
                if [[ -n "$bash_file" ]]; then
                    do_set bash "$new_version" "$bash_file";
                fi
                ;;
            *)
                info "Package file update functionality coming in Phase 6";
                info "Please manually update package files to version: $new_version";
                ;;
        esac
    else
        info "Please manually update package files to version: $new_version";
    fi
    
    return 0;
}

################################################################################
#
#  __update_package_version_with_details - Enhanced version update with UX details
#
################################################################################
# Arguments:
#   1: old_version - Previous version for display
#   2: new_version - New version to set
# Returns: 0 on success, 1 on failure
# Stream Usage: Detailed progress messages to stderr

__update_package_version_with_details() {
    local old_version="$1";
    local new_version="$2";
    local project_types;
    local target_file="";
    local update_type="";
    
    # Determine what we'll be updating
    if project_types=$(detect_project_type); then
        case "$project_types" in
            rust)
                target_file="Cargo.toml";
                update_type="Rust package";
                ;;
            javascript)  
                target_file="package.json";
                update_type="JavaScript package";
                ;;
            python)
                if [[ -f "pyproject.toml" ]]; then
                    target_file="pyproject.toml";
                else
                    target_file="setup.py";
                fi
                update_type="Python package";
                ;;
            bash)
                # Use intelligent pattern detection to get the exact file
                target_file=$(get_bash_project_file);
                if [[ -z "$target_file" ]]; then
                    # Fallback to legacy detection
                    target_file=$(detect_bash_version_file);
                fi
                local pattern;
                pattern=$(detect_bash_project_pattern 2>/dev/null);
                if [[ -n "$pattern" ]]; then
                    case "$pattern" in
                        bashfx-buildsh) update_type="BashFX build.sh project";;
                        bashfx-simple) update_type="BashFX simple project";;
                        bash-standalone) update_type="Bash standalone script";;
                        bash-semvrc) update_type="Bash semvrc project";;
                        *) update_type="Bash script";;
                    esac
                else
                    update_type="Bash script";
                fi
                ;;
            *)
                info "Multi-language project detected: $project_types";
                info "Please manually update package files to version: $new_version";
                return 0;
                ;;
        esac
    else
        info "Please manually update package files to version: $new_version";
        return 0;
    fi
    
    # Show what we're about to do using boxy integration
    if [[ -n "$target_file" ]]; then
        local update_info="Type: ${update_type}\nFile: ${target_file}\nChange: ${old_version} â†’ ${new_version}";
        view "warning" "ðŸ“ Version Update" "$update_info";
        
        # Perform the update using existing functionality
        case "$project_types" in
            rust)
                do_set rust "$new_version";;
            javascript)  
                do_set js "$new_version";;
            python)
                do_set python "$new_version";;
            bash)
                if [[ -n "$target_file" ]]; then
                    do_set bash "$new_version" "$target_file";
                fi
                ;;
        esac
    else
        warn "Could not determine target file for update";
        return 1;
    fi
    
    return 0;
}

################################################################################
#
#  do_drift - Analyze version drift between sources
#
################################################################################
# Returns: 0 if drift detected, 1 if aligned
# Stream Usage: Analysis output to stderr

do_drift() {
    local view_mode
    view_mode=$(get_view_mode)

    # Data view passthrough
    if [[ "$view_mode" == "data" ]]; then
        status_data
        local kd i key val drift="0" pkg git
        IFS=';' read -ra kd <<< "$(status_data 2>/dev/null || true)"
        for i in "${kd[@]}"; do
            key="${i%%=*}"; val="${i#*=}";
            case "$key" in
                pkg) pkg="$val";;
                git) git="$val";;
            esac
        done
        local git_num="${git#v}"
        if [[ -n "$pkg" ]] && [[ -n "$git_num" ]] && [[ "$pkg" != "$git_num" ]]; then
            drift="1"
        else
            drift="0"
        fi
        if [[ "$drift" == "1" ]]; then
            return 0
        else
            return 1
        fi
    fi

    # Human view: use drift_data for consistency
    local data kd i key val pkg git calc drift="0"
    data=$(status_data 2>/dev/null || true)
    IFS=';' read -ra kd <<< "$data"
    for i in "${kd[@]}"; do
        key="${i%%=*}"; val="${i#*=}"
        case "$key" in
            pkg) pkg="$val";;
            git) git="$val";;
            calc) calc="$val";;
        esac
    done
    local git_num="${git#v}"
    if [[ -n "$pkg" ]] && [[ -n "$git_num" ]] && [[ "$pkg" != "$git_num" ]]; then
        drift="1"
    else
        drift="0"
    fi

    local msg=""
    msg+="~~ Version Drift Analysis ~~\n"
    msg+="ðŸ“¦ PKG: [${grey}${pkg:- -none-}${x}]\n"
    msg+="ðŸ·ï¸ GIT: [${grey}${git:- -none-}${x}]\n"
    msg+="ðŸ”¢ CALC: [${grey}${calc:- -none-}${x}]\n"
    if [[ "$drift" == "1" ]]; then
        msg+="ðŸ§­ STATE: [${orange}DRIFT${x}]\n"
        msg+="Run 'semv sync' to resolve version drift.\n"
        view_drift "$msg" drift
        return 0
    else
        msg+="ðŸ§­ STATE: [${green}ALIGNED${x}]\n"
        view_drift "$msg" aligned
        return 1
    fi
}

################################################################################
#
#  do_validate - Validate version consistency and project structure
#
################################################################################
# Returns: 0 if valid, 1 if validation failed
# Stream Usage: Validation results to stderr

do_validate() {
    local ret=0;
    local issues=0;
    
    info "Validating project version consistency...";
    
    # Check project structure (non-fatal if tags exist)
    if ! detect_project_type >/dev/null; then
        if has_semver; then
            warn "No supported package files detected; using tags as authority"
        else
            error "Project structure validation failed"
            ((issues++))
        fi
    fi
    
    # Check for version conflicts (do_drift returns 0 on drift, 1 on aligned)
    if do_drift >/dev/null 2>&1; then
        warn "Version drift detected between sources";
        ((issues++));
    fi
    
    # Check git repository state
    if ! is_repo; then
        error "Not in a git repository";
        ((issues++));
    fi
    
    # Check for uncommitted changes (warn only; not a validation failure)
    if ! is_not_staged; then
        warn "Uncommitted changes detected";
        info "Consider committing changes before version operations";
    fi
    
    # Report results
    if [[ "$issues" -eq 0 ]]; then
        okay "Project validation passed - ready for version operations";
        ret=0;
    else
        error "Found $issues validation issues";
        info "Run 'semv drift' for detailed analysis";
        ret=1;
    fi
    
    return "$ret";
}

# Mark resolve as loaded (load guard pattern)
readonly SEMV_RESOLVE_LOADED=1;

# === 10_getset.sh ===
#
# 10_getset.sh - Version Get/Set Commands
# semv-revision: 2.0.0
# Part of SEMV - Semantic Version Manager
#

################################################################################
#
#  Get Commands - Version Information Retrieval
#
################################################################################

################################################################################
#
#  do_get - Main get command dispatcher
#
################################################################################
# Arguments:
#   1: source_type - Type of source (rust, js, python, bash, all)
#   2: file_path - Optional file path for bash projects
# Returns: 0 on success, 1 on failure
# Local Variables: source_type, file_path, version, ret
# Stream Usage: Version info to stdout, messages to stderr

do_get() {
    local source_type="$1";
    local file_path="${2:-}";
    local version;
    local ret=1;
    
    case "$source_type" in
        rust|cargo)
            version=$(get_rust_version);
            if [[ -n "$version" ]]; then
                printf "rust (Cargo.toml): %s\n" "$version";
                ret=0;
            else
                error "No Rust version found (Cargo.toml missing or invalid)";
            fi
            ;;
        js|javascript|node|npm)
            version=$(get_javascript_version);
            if [[ -n "$version" ]]; then
                printf "javascript (package.json): %s\n" "$version";
                ret=0;
            else
                error "No JavaScript version found (package.json missing or invalid)";
            fi
            ;;
        python|py)
            version=$(get_python_version);
            if [[ -n "$version" ]]; then
                printf "python (pyproject.toml/setup.py): %s\n" "$version";
                ret=0;
            else
                error "No Python version found (pyproject.toml/setup.py missing or invalid)";
            fi
            ;;
        bash|sh)
            if [[ -z "$file_path" ]]; then
                # Try intelligent bash project detection
                file_path=$(get_bash_project_file);
                if [[ -z "$file_path" ]]; then
                    # Fallback to legacy detection
                    file_path=$(detect_bash_version_file);
                fi
            fi
            
            if [[ -n "$file_path" ]] && [[ -f "$file_path" ]]; then
                version=$(get_bash_version "$file_path");
                if [[ -n "$version" ]]; then
                    local pattern;
                    pattern=$(detect_bash_project_pattern 2>/dev/null);
                    if [[ -n "$pattern" ]]; then
                        printf "bash (%s, pattern: %s): %s\n" "$file_path" "$pattern" "$version";
                    else
                        printf "bash (%s): %s\n" "$file_path" "$version";
                    fi
                    ret=0;
                else
                    error "No version comment found in: $file_path";
                fi
            else
                error "Bash file not specified or not found: ${file_path:-auto-detect failed}";
                local folder_name;
                folder_name=$(basename "$(pwd)");
                info "Auto-detection suggestions:";
                if [[ -f "build.sh" && -d "parts" ]]; then
                    info "  BashFX build.sh: Add version to first part file";
                elif [[ "$folder_name" == *-* ]]; then
                    local suffix="${folder_name##*-}";
                    info "  BashFX simple: Add version to ${suffix}.sh";
                else
                    info "  Manual usage: semv get bash ./my-script.sh";
                fi
            fi
            ;;
        all)
            do_get_all;
            ret=$?;
            ;;
        *)
            error "Unknown source type: $source_type";
            info "Supported: rust, javascript, python, bash, all";
            ;;
    esac
    
    return "$ret";
}

################################################################################
#
#  do_get_all - Show all version sources
#
################################################################################
# Returns: 0 if any versions found, 1 if none found
# Local Variables: found_any, version, project_types, git_version, semv_version
# Stream Usage: Version info to stdout, messages to stderr

do_get_all() {
    local found_any=0;
    local version;
    local project_types;
    local git_version;
    local semv_version;
    local output;
    
    info "Scanning all version sources...";
    
    # Build output while tracking if we found anything
    output=""
    output+="\n"
    
    # Package file versions
    output+="\n${bld}=== Package Files ===${x}\n"
    
    # Rust
    version=$(get_rust_version 2>/dev/null);
    if [[ -n "$version" ]]; then
        output+="  rust (Cargo.toml): ${version}\n"
        found_any=1;
    fi
    
    # JavaScript  
    version=$(get_javascript_version 2>/dev/null);
    if [[ -n "$version" ]]; then
        output+="  javascript (package.json): ${version}\n"
        found_any=1;
    fi
    
    # Python
    version=$(get_python_version 2>/dev/null);
    if [[ -n "$version" ]]; then
        output+="  python (pyproject.toml/setup.py): ${version}\n"
        found_any=1;
    fi
    
    # Bash - Enhanced with pattern detection
    local bash_file;
    local bash_pattern;
    
    # Try intelligent detection first
    bash_file=$(get_bash_project_file 2>/dev/null);
    bash_pattern=$(detect_bash_project_pattern 2>/dev/null);
    
    # Fallback to legacy detection
    if [[ -z "$bash_file" ]]; then
        bash_file=$(detect_bash_version_file 2>/dev/null);
        bash_pattern="legacy";
    fi
    
    if [[ -n "$bash_file" ]]; then
        version=$(get_bash_version "$bash_file" 2>/dev/null);
        if [[ -n "$version" ]]; then
            if [[ -n "$bash_pattern" && "$bash_pattern" != "legacy" ]]; then
                output+="  bash (${bash_file}, pattern: ${bash_pattern}): ${version}\n"
            else
                output+="  bash (${bash_file}): ${version}\n"
            fi
            found_any=1;
        fi
    fi
    
    # Git information
    output+="\n${bld}=== Git Repository ===${x}\n"
    
    git_version=$(_latest_tag 2>/dev/null);
    if [[ -n "$git_version" ]]; then
        output+="  latest tag: ${git_version}\n"
        found_any=1;
    else
        output+="  latest tag: none\n"
    fi
    
    # Semv calculations
    output+="\n${bld}=== SEMV Analysis ===${x}\n"
    
    semv_version=$(do_next_semver "${git_version:-v0.0.0}" 2>/dev/null);
    if [[ -n "$semv_version" ]]; then
        output+="  calculated next: ${semv_version}\n"
        found_any=1;
    fi
    
    # Build information
    local build_number;
    build_number=$(_build_number 2>/dev/null);
    if [[ -n "$build_number" ]]; then
        output+="  build number: ${build_number}\n"
    fi
    
    # Project detection summary with enhanced bash pattern info
    output+="\n${bld}=== Project Type ===${x}\n"
    project_types=$(detect_project_type 2>/dev/null);
    if [[ -n "$project_types" ]]; then
        output+="  detected: ${project_types}\n"
        
        # If bash is detected, show the specific pattern
        if [[ "$project_types" == *"bash"* ]]; then
            local detected_bash_pattern;
            detected_bash_pattern=$(detect_bash_project_pattern 2>/dev/null);
            if [[ -n "$detected_bash_pattern" ]]; then
                case "$detected_bash_pattern" in
                    bashfx-buildsh)
                        output+="  bash details: BashFX build.sh pattern (build.sh + parts/ + build.map)\n"
                        ;;
                    bashfx-simple)
                        output+="  bash details: BashFX simple pattern (prefix-name/ + name.sh)\n"
                        ;;
                    bash-standalone)
                        output+="  bash details: Standalone script (foldername.sh)\n"
                        ;;
                    bash-semvrc)
                        output+="  bash details: Legacy semvrc configuration\n"
                        ;;
                    bash-generic)
                        output+="  bash details: Generic version-commented script\n"
                        ;;
                    *)
                        output+="  bash details: Pattern $detected_bash_pattern\n"
                        ;;
                esac
            fi
        fi
    else
        output+="  detected: none/unknown\n"
    fi
    
    # Check if we found anything meaningful
    if [[ "$found_any" -eq 0 ]]; then
        printf "\n%sNo version information found%s\n" "$yellow" "$x";
        return 1;
    fi
    
    # Output with optional boxy wrapper
    if [[ "$SEMV_USE_BOXY" == "1" ]] && command_exists boxy; then
        printf "%b" "$output" | boxy --theme info --title "ðŸ“Š Version Summary"
    else
        printf "%b" "$output"
    fi
    
    return 0;
}

################################################################################
#
#  Individual Get Functions  
#
################################################################################

################################################################################
#
#  get_rust_version - Extract version from Cargo.toml
#
################################################################################
# Returns: 0 on success, 1 on failure
# Stream Usage: Version to stdout

get_rust_version() {
    if [[ ! -f "Cargo.toml" ]]; then
        return 1;
    fi
    
    __get_single_package_version "rust";
}

################################################################################
#
#  get_javascript_version - Extract version from package.json
#
################################################################################
# Returns: 0 on success, 1 on failure
# Stream Usage: Version to stdout

get_javascript_version() {
    if [[ ! -f "package.json" ]]; then
        return 1;
    fi
    
    __get_single_package_version "javascript";
}

################################################################################
#
#  get_python_version - Extract version from Python package files
#
################################################################################
# Returns: 0 on success, 1 on failure
# Stream Usage: Version to stdout

get_python_version() {
    if [[ ! -f "pyproject.toml" ]] && [[ ! -f "setup.py" ]]; then
        return 1;
    fi
    
    __get_single_package_version "python";
}

################################################################################
#
#  get_bash_version - Extract version from bash file comment
#
################################################################################
# Arguments:
#   1: file_path - Path to bash file
# Returns: 0 on success, 1 on failure
# Stream Usage: Version to stdout

get_bash_version() {
    local file_path="$1";
    
    if [[ ! -f "$file_path" ]]; then
        return 1;
    fi
    
    # Look for semv-version, semv-revision, or version comment (exclude lines with $ or " which are code)
    local version;
    version=$(grep -E "^[[:space:]]*#[[:space:]]*(semv-version|semv-revision|version):" "$file_path" | grep -v '\$\|"' | head -1 | sed 's/.*:[[:space:]]*//');
    
    if [[ -n "$version" ]]; then
        # Clean up version (remove v prefix, whitespace, and trailing text after version)
        version=$(echo "$version" | sed 's/^v//;s/[[:space:]]*$//g' | awk '{print $1}');
        printf "%s\n" "$version";
        return 0;
    fi
    
    return 1;
}

################################################################################
#
#  detect_bash_version_file - Find bash file with version comment
#
################################################################################
# Returns: 0 on success, 1 on failure
# Stream Usage: File path to stdout

detect_bash_version_file() {
    # Check .semvrc first
    if [[ -f ".semvrc" ]]; then
        local bash_file;
        bash_file=$(grep "^BASH_VERSION_FILE=" ".semvrc" 2>/dev/null | cut -d'=' -f2 | tr -d '"'"'");
        if [[ -n "$bash_file" ]] && [[ -f "$bash_file" ]]; then
            printf "%s\n" "$bash_file";
            return 0;
        fi
    fi
    
    # Search for bash files with version comments
    local bash_files;
    mapfile -t bash_files < <(find . -maxdepth 2 -name "*.sh" -type f 2>/dev/null)
    
    for file in "${bash_files[@]}"; do
        if grep -q -E "^[[:space:]]*#[[:space:]]*(semv-version|version):" "$file" 2>/dev/null; then
            printf "%s\n" "$file";
            return 0;
        fi
    done
    
    return 1;
}

################################################################################
#
#  Set Commands - Version Information Update
#
################################################################################

################################################################################
#
#  do_set - Main set command dispatcher
#
################################################################################  
# Arguments:
#   1: source_type - Type of source (rust, js, python, bash, all)
#   2: new_version - Version to set
#   3: file_path - Optional file path for bash projects
# Returns: 0 on success, 1 on failure
# Local Variables: source_type, new_version, file_path, ret
# Stream Usage: Success/failure messages to stderr

do_set() {
    local source_type="$1";
    local new_version="$2";
    local file_path="${3:-}";
    local ret=1;
    
    if [[ -z "$new_version" ]]; then
        error "Version required";
        info "Usage: semv set $source_type VERSION [FILE]";
        return 1;
    fi
    
    # Validate version format
    if ! __validate_semver "$new_version"; then
        error "Invalid semantic version format: $new_version";
        info "Expected format: 1.2.3 or v1.2.3";
        return 1;
    fi
    
    # Clean version (remove v prefix)
    new_version=$(echo "$new_version" | sed 's/^v//');
    
    case "$source_type" in
        rust|cargo)
            if set_rust_version "$new_version"; then
                okay "Updated Rust version to: $new_version";
                ret=0;
            else
                error "Failed to update Rust version";
            fi
            ;;
        js|javascript|node|npm)
            if set_javascript_version "$new_version"; then
                okay "Updated JavaScript version to: $new_version";
                ret=0;
            else
                error "Failed to update JavaScript version";
            fi
            ;;
        python|py)
            if set_python_version "$new_version"; then
                okay "Updated Python version to: $new_version";
                ret=0;
            else
                error "Failed to update Python version";
            fi
            ;;
        bash|sh)
            if [[ -z "$file_path" ]]; then
                # Use intelligent pattern detection first
                file_path=$(get_bash_project_file);
                if [[ -z "$file_path" ]]; then
                    # Fallback to legacy detection
                    file_path=$(detect_bash_version_file);
                fi
            fi
            
            if [[ -n "$file_path" ]] && [[ -f "$file_path" ]]; then
                if set_bash_version "$file_path" "$new_version"; then
                    okay "Updated Bash version to: $new_version in $file_path";
                    ret=0;
                else
                    error "Failed to update Bash version in: $file_path";
                fi
            else
                error "Bash file not specified or not found: ${file_path:-auto-detect failed}";
                info "Usage: semv set bash VERSION ./my-script.sh";
            fi
            ;;
        all)
            if do_set_all "$new_version"; then
                okay "Updated all package versions to: $new_version";
                ret=0;
            else
                error "Failed to update one or more package versions";
            fi
            ;;
        *)
            error "Unknown source type: $source_type";
            info "Supported: rust, javascript, python, bash, all";
            ;;
    esac
    
    return "$ret";
}

################################################################################
#
#  do_set_all - Update all detected package versions
#
################################################################################
# Arguments:
#   1: new_version - Version to set everywhere
# Returns: 0 if all updates successful, 1 if any failed
# Local Variables: new_version, success_count, fail_count
# Stream Usage: Progress messages to stderr

do_set_all() {
    local new_version="$1";
    local success_count=0;
    local fail_count=0;
    
    info "Updating all package versions to: $new_version";
    
    # Update each detected project type
    if is_project_type "rust"; then
        if set_rust_version "$new_version"; then
            info "  âœ“ Rust (Cargo.toml)";
            ((success_count++));
        else
            warn "  âœ— Rust (Cargo.toml)";
            ((fail_count++));
        fi
    fi
    
    if is_project_type "javascript"; then
        if set_javascript_version "$new_version"; then
            info "  âœ“ JavaScript (package.json)";
            ((success_count++));
        else
            warn "  âœ— JavaScript (package.json)";
            ((fail_count++));
        fi
    fi
    
    if is_project_type "python"; then
        if set_python_version "$new_version"; then
            info "  âœ“ Python (pyproject.toml/setup.py)";
            ((success_count++));
        else
            warn "  âœ— Python (pyproject.toml/setup.py)";
            ((fail_count++));
        fi
    fi
    
    # Update bash files if detected
    local bash_file;
    bash_file=$(detect_bash_version_file 2>/dev/null);
    if [[ -n "$bash_file" ]]; then
        if set_bash_version "$bash_file" "$new_version"; then
            info "  âœ“ Bash ($bash_file)";
            ((success_count++));
        else
            warn "  âœ— Bash ($bash_file)";
            ((fail_count++));
        fi
    fi
    
    # Report results
    if [[ "$success_count" -gt 0 ]]; then
        okay "Updated $success_count package file(s)";
        if [[ "$fail_count" -gt 0 ]]; then
            warn "Failed to update $fail_count package file(s)";
            return 1;
        fi
        return 0;
    else
        error "No package files found to update";
        return 1;
    fi
}

################################################################################
#
#  Individual Set Functions
#
################################################################################

################################################################################
#
#  set_rust_version - Update version in Cargo.toml
#
################################################################################
# Arguments:
#   1: new_version - Version to set
# Returns: 0 on success, 1 on failure

set_rust_version() {
    local new_version="$1";
    
    if [[ ! -f "Cargo.toml" ]]; then
        return 1;
    fi
    
    # Use awk to update version in [package] section
    if awk -v new_ver="$new_version" '
        /^\[package\]/ { in_package=1; print; next }
        /^\[/ { in_package=0; print; next }
        in_package && /^version\s*=/ {
            print "version = \"" new_ver "\""
            next
        }
        { print }
    ' "Cargo.toml" > "Cargo.toml.tmp" && mv "Cargo.toml.tmp" "Cargo.toml"; then
        return 0;
    fi
    
    return 1;
}

################################################################################
#
#  set_javascript_version - Update version in package.json
#
################################################################################
# Arguments:
#   1: new_version - Version to set
# Returns: 0 on success, 1 on failure

set_javascript_version() {
    local new_version="$1";
    
    if [[ ! -f "package.json" ]]; then
        return 1;
    fi
    
    # Use sed to update version field
    if sed -i.bak 's/"version"[[:space:]]*:[[:space:]]*"[^"]*"/"version": "'"$new_version"'"/' "package.json"; then
        rm -f "package.json.bak" 2>/dev/null;
        return 0;
    fi
    
    return 1;
}

################################################################################
#
#  set_python_version - Update version in Python package files
#
################################################################################
# Arguments:
#   1: new_version - Version to set
# Returns: 0 on success, 1 on failure

set_python_version() {
    local new_version="$1";
    
    if [[ -f "pyproject.toml" ]]; then
        # Update pyproject.toml
        if awk -v new_ver="$new_version" '
            /^\[project\]/ { in_project=1; print; next }
            /^\[/ { in_project=0; print; next }
            in_project && /^version\s*=/ {
                print "version = \"" new_ver "\""
                next
            }
            { print }
        ' "pyproject.toml" > "pyproject.toml.tmp" && mv "pyproject.toml.tmp" "pyproject.toml"; then
            return 0;
        fi
    elif [[ -f "setup.py" ]]; then
        # Update setup.py (basic sed replacement)
        if sed -i.bak 's/version[[:space:]]*=[[:space:]]*['"'"'"][^"'"'"']*['"'"'"]/version="'"$new_version"'"/' "setup.py"; then
            rm -f "setup.py.bak" 2>/dev/null;
            return 0;
        fi
    fi
    
    return 1;
}

################################################################################
#
#  set_bash_version - Update version comment in bash file
#
################################################################################
# Arguments:
#   1: file_path - Path to bash file
#   2: new_version - Version to set
# Returns: 0 on success, 1 on failure

set_bash_version() {
    local file_path="$1";
    local new_version="$2";
    
    if [[ ! -f "$file_path" ]]; then
        return 1;
    fi
    
    # Update existing version comment or add if missing
    if grep -q -E "^[[:space:]]*#[[:space:]]*(semv-version|version):" "$file_path"; then
        # Update existing comment  
        if sed -i.bak "s/^[[:space:]]*#[[:space:]]*\(semv-version\|version\):[[:space:]]*.*$/# semv-version: $new_version/" "$file_path"; then
            rm -f "${file_path}.bak" 2>/dev/null;
            return 0;
        fi
    else
        # Add version comment after shebang
        if sed -i.bak "2i\\
# semv-version: $new_version" "$file_path"; then
            rm -f "${file_path}.bak" 2>/dev/null;
            return 0;
        fi
    fi
    
    return 1;
}

# Mark getset as loaded (load guard pattern)
readonly SEMV_GETSET_LOADED=1;

# === 11_semver.sh ===
#
# semv-semver.sh - Core Semantic Versioning Business Logic
# semv-revision: 2.0.0
# BashFX compliant semver operations
#

################################################################################
#
#  Core Semver Functions
#
################################################################################

################################################################################
#
#  do_latest_tag - Get latest git tag (any format)
#
################################################################################
# Returns: 0 if tags exist, 1 if none found
# Local Variables: latest, ret
# Outputs: Latest tag to stdout

do_latest_tag() {
    local latest;
    local ret=1;
    
    if is_repo; then
        latest=$(__git_latest_tag);
        if [[ -n "$latest" ]]; then
            printf "%s\n" "$latest";
            ret=0;
        fi
    fi
    
    return "$ret";
}

################################################################################
#
#  do_latest_semver - Get latest semantic version tag
#
################################################################################
# Returns: 0 if semver tags exist, 1 if none found
# Local Variables: latest, ret
# Outputs: Latest semver tag to stdout

do_latest_semver() {
    local latest;
    local ret=1;
    
    if has_semver; then
        latest=$(__git_latest_semver);
        if [[ -n "$latest" ]]; then
            printf "%s\n" "$latest";
            ret=0;
        else
            error "No semver tags found";
        fi
    else
        error "No semver tags found";
    fi
    
    return "$ret";
}

################################################################################
#
#  do_change_count - Analyze commit changes since tag
#
################################################################################
# Arguments:
#   1: tag (optional) - Tag to count from (defaults to latest)
# Returns: 0 if changes found, 1 if no changes
# Local Variables: tag, break_count, feat_count, fix_count, dev_count, ret
# Side Effects: Sets global b_major, b_minor, b_patch, build_s, note_s

do_change_count() {
    local tag="${1:-$(do_latest_tag)}";
    local break_count;
    local feat_count;
    local fix_count;
    local dev_count;
    local ret=1;
    
    if [[ -z "$tag" ]]; then
        error "No tag specified and no tags found";
        return 1;
    fi
    
    # Initialize bump flags
    b_major=0;
    b_minor=0;
    b_patch=0;
    
    # Count commits by type since tag
    break_count=$(since_last "$tag" "$SEMV_MAJ_LABEL");
    feat_count=$(since_last "$tag" "$SEMV_FEAT_LABEL");
    fix_count=$(since_last "$tag" "$SEMV_FIX_LABEL");
    dev_count=$(since_last "$tag" "$SEMV_DEV_LABEL");
    build_s=$(__git_build_count);
    note_s="$dev_count";
    
    trace "Changes since $tag: major=$break_count minor=$feat_count patch=$fix_count dev=$dev_count";
    
    # Determine version bump based on commit types
    if [[ "$break_count" -ne 0 ]]; then
        trace "Found breaking changes - major bump";
        b_major=1;
        b_minor=0;
        b_patch=0;
        ret=0;
    elif [[ "$feat_count" -ne 0 ]]; then
        trace "Found new features - minor bump";
        b_minor=1;
        b_patch=0;
        ret=0;
    elif [[ "$fix_count" -ne 0 ]]; then
        trace "Found bug fixes - patch bump";
        b_patch=1;
        ret=0;
    elif [[ "$dev_count" -ne 0 ]]; then
        trace "Found dev notes - no version bump";
        ret=0;
    fi
    
    return "$ret";
}

################################################################################
#
#  do_next_semver - Calculate next semantic version
#
################################################################################
# Arguments:
#   1: force (optional) - Skip confirmation if "0"
# Returns: 0 on success, 1 on failure
# Local Variables: tag, parts, major, minor, patch, extra, new_version, ret
# Outputs: Next version to stdout

do_next_semver() {
    local force="${1:-1}";
    local tag;
    local parts;
    local major;
    local minor; 
    local patch;
    local extra;
    local new_version;
    local tail_suffix="";
    local ret=1;
    
    # Get latest tag as base
    tag=$(do_latest_tag);
    if [[ -z "$tag" ]]; then
        error "No tags found to bump from";
        return 1;
    fi
    
    # Parse current version
    parts=$(split_vers "$tag");
    if [[ $? -ne 0 ]] || [[ -z "$parts" ]]; then
        error "Invalid version format: $tag";
        return 1;
    fi
    
    # Extract version components
    local -a components=($parts);
    major="${components[0]:-0}";
    minor="${components[1]:-0}";
    patch="${components[2]:-0}";
    extra="${components[3]:-}";
    
    # Validate numeric components
    if ! [[ "$major" =~ ^[0-9]+$ ]] || ! [[ "$minor" =~ ^[0-9]+$ ]] || ! [[ "$patch" =~ ^[0-9]+$ ]]; then
        error "Non-numeric version components from: $tag (got major='$major', minor='$minor', patch='$patch')";
        return 1;
    fi
    
    # Analyze changes to determine bump
    if ! do_change_count "$tag"; then
        if [[ "$opt_dev_note" -eq 0 ]]; then
            error "No changes since last tag ($tag)";
            return 1;
        fi
    fi
    
    # Apply version bumps
    major=$((major + b_major));
    minor=$((minor + b_minor));
    patch=$((patch + b_patch));
    
    # Reset lower components when higher ones bump
    if [[ "$b_major" -eq 1 ]]; then
        minor=0;
        patch=0;
    elif [[ "$b_minor" -eq 1 ]]; then
        patch=0;
    fi
    
    # Build new version string
    new_version="v${major}.${minor}.${patch}";
    
    # Add development suffix if enabled
    if [[ "$opt_dev_note" -eq 0 ]]; then
        if [[ "$note_s" -ne 0 ]]; then
            trace "Dev notes found - adding dev suffix";
            tail_suffix="-dev_${note_s}";
        else
            trace "Clean build - adding build suffix";
            tail_suffix="-build_${build_s}";
        fi
        new_version="${new_version}${tail_suffix}";
    fi
    
    trace "Version calculation: $tag -> $new_version";
    
    # Confirmation for releases with dev notes
    if [[ "$force" -ne 0 ]] && [[ "$note_s" -ne 0 ]] && [[ "$opt_dev_note" -eq 1 ]]; then
        warn "There are [$note_s] dev notes and --dev flag is disabled";
        info "Current: $tag";
        info "Next: $new_version";
        warn "You should only bump versions if dev notes are resolved";
        
        if ! __confirm "Continue with version bump"; then
            error "Version bump cancelled";
            return 1;
        fi
    fi
    
    printf "%s\n" "$new_version";
    ret=0;
    return "$ret";
}

################################################################################
#
#  Build File Generation
#
################################################################################

################################################################################
#
#  do_build_file - Generate build information file
#
################################################################################
# Arguments:
#   1: filename (optional) - Build file name (default: "build.inf")
# Returns: 0 on success, 1 on failure
# Local Variables: filename, dest, ret


do_build_file() {
    local filename="${1:-$SEMV_BUILD_FILE}";
    local dest;
    local ret=1;
    
    # Skip if cursor disabled
    if [[ "$opt_no_cursor" -eq 0 ]]; then
        trace "Build cursor disabled - skipping file generation";
        return 0;
    fi
    
    # Determine destination path
    if [[ -n "$opt_build_dir" ]]; then
        dest="$opt_build_dir/$filename";
        # Create directory if it doesn't exist
        mkdir -p "$opt_build_dir" || {
            error "Cannot create build directory: $opt_build_dir";
            return 1;
        }
    else
        dest="./$filename";
    fi
    
    # Generate comprehensive build info in key=value format
    local build_content;
    local timestamp;
    local user project branch main_branch changes_num;
    local build remote_build last_commit_time;
    local latest_tag release_tag current_version;
    
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ" 2>/dev/null || date);
    user=$(git config user.name 2>/dev/null || whoami);
    project=$(git remote get-url origin 2>/dev/null | sed 's|.*/||; s|\.git$||' || basename "$(pwd)");
    branch=$(git branch --show-current 2>/dev/null || "unknown");
    main_branch=$(which_main 2>/dev/null || echo "main");
    changes_num=$(git status --porcelain 2>/dev/null | wc -l || echo "0");
    build=$(git rev-list --count HEAD 2>/dev/null || echo "0");
    remote_build=$(git rev-list --count "origin/$main_branch" 2>/dev/null || echo "0");
    last_commit_time=$(git log -1 --format="%ci" 2>/dev/null || "unknown");
    latest_tag=$(git describe --tags --abbrev=0 2>/dev/null || "none");
    release_tag="none"; # TODO: implement release tag detection
    current_version=$(do_latest_semver 2>/dev/null || echo "unknown");
    
    # Generate key=value output
    printf -v build_content "%s\n" \
        "# Build Information Generated by SEMV ${SEMV_VERSION:-2.1.2}" \
        "# Generated: $timestamp" \
        "" \
        "user=$user" \
        "project=$project" \
        "branch=$branch" \
        "main_branch=$main_branch" \
        "changes=$changes_num" \
        "build_local=$build" \
        "build_remote=$remote_build" \
        "last_commit=$last_commit_time" \
        "latest_tag=$latest_tag" \
        "release_tag=$release_tag" \
        "current_version=$current_version" \
        "timestamp=$timestamp";
    
    # Write to file
    if printf "%s\n" "$build_content" > "$dest"; then
        info "Build info written to: $dest";
        ret=0;
    else
        error "Failed to write build info to: $dest";
    fi

    return "$ret";
}

# Mark semver as loaded (load guard pattern)
readonly SEMV_SEMVER_LOADED=1;

# === 12_lifecycle.sh ===
#
# semv-lifecycle.sh - Installation and Lifecycle Management
# semv-revision: 2.0.0
# BashFX compliant lifecycle functions
#

################################################################################
#
#  Installation Functions
#
################################################################################

################################################################################
#
#  do_install - Install semv to BashFX system
#
################################################################################
# Returns: 0 on success, 1 on failure
# Local Variables: ret, semv_bin, semv_lib
# Stream Usage: Messages to stderr

do_install() {
    local ret=1;
    local semv_bin="${XDG_BIN:-$HOME/.local/bin}/semv";
    local semv_lib="${XDG_LIB:-$HOME/.local/lib}/fx/semv";
    
    info "Installing SEMV to BashFX system...";
    
    # Ensure XDG+ directories exist
    if ! _ensure_xdg_paths; then
        error "Failed to create XDG+ directories";
        return 1;
    fi

    # Migrate RC from legacy location if present
    __migrate_rc_if_needed || true
    
    # Create semv lib directory
    if ! mkdir -p "$semv_lib"; then
        error "Failed to create semv library directory: $semv_lib";
        return 1;
    fi
    
    # Copy script to lib location
    if ! cp "$SEMV_PATH" "$semv_lib/semv.sh"; then
        error "Failed to copy semv script to library";
        return 1;
    fi
    
    # Create symlink in bin
    if ! ln -sf "$semv_lib/semv.sh" "$semv_bin"; then
        error "Failed to create binary symlink";
        return 1;
    fi
    
    # Make executable
    if ! chmod +x "$semv_lib/semv.sh"; then
        error "Failed to make script executable";
        return 1;
    fi
    
    # Create initial configuration
    if ! __create_default_config; then
        warn "Failed to create default configuration";
    fi
    
    # Create RC file for session state
    if ! __create_rc_file; then
        warn "Failed to create RC file";
    fi
    
    okay "SEMV installed successfully";
    info "Binary: $semv_bin";
    info "Library: $semv_lib";
    info "ETC (config): $SEMV_ETC_HOME";
    
    ret=0;
    return "$ret";
}

################################################################################
#
#  do_uninstall - Remove semv from BashFX system
#
################################################################################
# Returns: 0 on success, 1 on failure
# Local Variables: ret, semv_bin, semv_lib
# Stream Usage: Messages to stderr

do_uninstall() {
    local ret=1;
    local semv_bin="${XDG_BIN:-$HOME/.local/bin}/semv";
    local semv_lib="${XDG_LIB:-$HOME/.local/lib}/fx/semv";
    
    info "Uninstalling SEMV from BashFX system...";
    
    # Remove symlink
    if [[ -L "$semv_bin" ]]; then
        if rm "$semv_bin"; then
            okay "Removed binary symlink: $semv_bin";
        else
            error "Failed to remove binary symlink";
            return 1;
        fi
    fi
    
    # Remove library directory
    if [[ -d "$semv_lib" ]]; then
        if rm -rf "$semv_lib"; then
            okay "Removed library directory: $semv_lib";
        else
            error "Failed to remove library directory";
            return 1;
        fi
    fi
    
    # Ask about configuration removal
    if [[ -d "$SEMV_ETC_HOME" ]]; then
        if __confirm "Remove configuration directory ($SEMV_ETC_HOME)"; then
            if rm -rf "$SEMV_ETC_HOME"; then
                okay "Removed configuration directory";
            else
                warn "Failed to remove configuration directory";
            fi
        else
            info "Keeping configuration directory";
        fi
    fi
    
    # Ask about data removal
    if [[ -d "$SEMV_DATA" ]]; then
        if __confirm "Remove data directory ($SEMV_DATA)"; then
            if rm -rf "$SEMV_DATA"; then
                okay "Removed data directory";
            else
                warn "Failed to remove data directory";
            fi
        else
            info "Keeping data directory";
        fi
    fi
    
    okay "SEMV uninstalled successfully";
    ret=0;
    return "$ret";
}

################################################################################
#
#  do_reset - Reset configuration to defaults
#
################################################################################
# Returns: 0 on success, 1 on failure
# Local Variables: ret
# Stream Usage: Messages to stderr

do_reset() {
    local ret=1;
    
    info "Resetting SEMV configuration to defaults...";
    
    # Backup existing configuration
    if [[ -d "$SEMV_ETC_HOME" ]]; then
        local backup_dir="${SEMV_ETC_HOME}.backup.$(date +%s)";
        if cp -r "$SEMV_ETC_HOME" "$backup_dir"; then
            info "Backed up existing configuration to: $backup_dir";
        else
            warn "Failed to backup existing configuration";
        fi
    fi
    
    # Remove current configuration
    if [[ -d "$SEMV_ETC_HOME" ]]; then
        if ! rm -rf "$SEMV_ETC_HOME"; then
            error "Failed to remove current configuration";
            return 1;
        fi
    fi
    
    # Recreate default configuration
    if ! _ensure_xdg_paths; then
        error "Failed to recreate configuration directories";
        return 1;
    fi
    
    if ! __create_default_config; then
        error "Failed to create default configuration";
        return 1;
    fi
    
    if ! __create_rc_file; then
        error "Failed to create RC file";
        return 1;
    fi
    
    okay "Configuration reset successfully";
    ret=0;
    return "$ret";
}

################################################################################
#
#  do_status - Show installation and configuration status
#
################################################################################
# Returns: 0 always
# Local Variables: semv_bin, semv_lib, status
# Stream Usage: Messages to stderr

do_status() {
    local semv_bin="${XDG_BIN:-$HOME/.local/bin}/semv";
    local semv_lib="${XDG_LIB:-$HOME/.local/lib}/fx/semv";
    local status;
    
    info "SEMV Installation Status:";
    # Attempt RC migration passively during status
    __migrate_rc_if_needed || true
    
    # Check binary symlink
    if [[ -L "$semv_bin" ]] && [[ -x "$semv_bin" ]]; then
        okay "Binary: $semv_bin âœ“";
    else
        warn "Binary: $semv_bin âœ—";
    fi
    
    # Check library
    if [[ -f "$semv_lib/semv.sh" ]] && [[ -x "$semv_lib/semv.sh" ]]; then
        okay "Library: $semv_lib âœ“";
    else
        warn "Library: $semv_lib âœ—";
    fi
    
    # Check configuration (ETC)
    if [[ -d "$SEMV_ETC_HOME" ]]; then
        okay "ETC (config): $SEMV_ETC_HOME âœ“";
    else
        warn "ETC (config): $SEMV_ETC_HOME âœ—";
    fi
    
    # Check data directory
    if [[ -d "$SEMV_DATA" ]]; then
        okay "Data: $SEMV_DATA âœ“";
    else
        warn "Data: $SEMV_DATA âœ—";
    fi
    
    # Check RC file
    if [[ -f "$SEMV_RC" ]]; then
        okay "RC File: $SEMV_RC âœ“";
    else
        warn "RC File: $SEMV_RC âœ—";
    fi
    
    return 0;
}

################################################################################
#
#  Configuration Helper Functions
#
################################################################################

################################################################################
#
#  __create_default_config - Create default configuration files
#
################################################################################
# Returns: 0 on success, 1 on failure
# Local Variables: config_file, ret
# Stream Usage: Messages to stderr

__create_default_config() {
    local config_file="$SEMV_ETC_HOME/config";
    local ret=1;
    
    if ! mkdir -p "$SEMV_ETC_HOME"; then
        return 1;
    fi
    
    # Create main configuration file
    cat > "$config_file" << 'EOF'
# SEMV Configuration File
# semv-revision: 2.0.0

# Commit label configuration (SEMV v2.0)
SEMV_MAJ_LABEL="(major|breaking|api)"
SEMV_FEAT_LABEL="(feat|feature|add|minor)"
SEMV_FIX_LABEL="(fix|patch|bug|hotfix|up)"
SEMV_DEV_LABEL="dev"

# Build configuration
SEMV_MIN_BUILD=1000

# Environment overrides
NO_BUILD_CURSOR=${NO_BUILD_CURSOR:-}
QUIET_MODE=${QUIET_MODE:-}
DEBUG_MODE=${DEBUG_MODE:-}
TRACE_MODE=${TRACE_MODE:-}
EOF

    if [[ -f "$config_file" ]]; then
        ret=0;
    fi
    
    return "$ret";
}

################################################################################
#
#  __create_rc_file - Create RC file for session state
#
################################################################################
# Returns: 0 on success, 1 on failure
# Local Variables: ret
# Stream Usage: Messages to stderr

__create_rc_file() {
    local ret=1;
    
    # Ensure any legacy RC is migrated before (re)creation
    __migrate_rc_if_needed || true
    
    if ! mkdir -p "$(dirname "$SEMV_RC")"; then
        return 1;
    fi
    
    # Create RC file with current state
    cat > "$SEMV_RC" << EOF
# SEMV Session State
# Generated: $(date)
# semv-revision: 2.0.0

SEMV_INSTALLED=1
SEMV_INSTALL_DATE=$(date +%s)
SEMV_VERSION=2.0.0
SEMV_ETC_HOME=$SEMV_ETC_HOME
SEMV_CONFIG=$SEMV_CONFIG
SEMV_DATA_HOME=$SEMV_DATA_HOME
EOF

    if [[ -f "$SEMV_RC" ]]; then
        ret=0;
    fi
    
    return "$ret";
}

################################################################################
#
#  __migrate_rc_if_needed - Move legacy RC to SEMV_ETC if found
#
################################################################################
# Returns: 0 on success or nothing to do, 1 on failure

__migrate_rc_if_needed() {
    local legacy_rc="${XDG_HOME:-$HOME/.local}/fx/semv/.semv.rc";
    local target_rc="$SEMV_RC";
    local target_dir
    target_dir="$(dirname "$target_rc")"
    
    if [[ -f "$legacy_rc" ]] && [[ ! -f "$target_rc" ]]; then
        mkdir -p "$target_dir" 2>/dev/null || return 1
        if mv "$legacy_rc" "$target_rc"; then
            okay "Migrated RC to: $target_rc";
            return 0;
        else
            warn "Failed to migrate RC from legacy location";
            return 1;
        fi
    fi
    return 0;
}

# Mark lifecycle as loaded (load guard pattern)
readonly SEMV_LIFECYCLE_LOADED=1;

# === 13_commands.sh ===
#
# semv-commands.sh - High-Order Command Functions
# semv-revision: 2.0.0
# BashFX compliant command implementations
#

################################################################################
#
#  Version Bump Commands
#
################################################################################

################################################################################
#
#  do_bump - Create and push new version tag
#
################################################################################
# Arguments:
#   1: force (optional) - Skip confirmations if "0"
# Returns: 0 on success, 1 on failure
# Local Variables: force, latest, new_version, ret

do_bump() {
    local force="${1:-1}";
    local latest;
    local new_version;
    local ret=1;
    
    if ! is_repo; then
        error "Not in a git repository";
        return 1;
    fi

    # Branch protection: only allow bumps on main/master branch
    if ! is_main; then
        local current_branch;
        current_branch=$(this_branch);
        error "Version bumps are only allowed on main/master branch";
        error "Current branch: ${current_branch:-unknown}";
        error "Switch to main branch and try again";
        return 1;
    fi

    # Ensure repository has a semv baseline for friendlier guidance
    if ! require_semv_baseline; then
        return 1;
    fi
    
    # Get current and next versions
    latest=$(do_latest_tag);
    new_version=$(do_next_semver "$force");
    ret=$?;
    
    if [[ "$ret" -eq 0 ]] && [[ -n "$new_version" ]]; then
        trace "Bump: $latest -> $new_version";
        
        if _do_retag "$new_version" "$latest"; then
            okay "Version bumped successfully: $new_version";
            ret=0;
        else
            error "Failed to create version tag";
            ret=1;
        fi
    else
        error "Failed to calculate next version";
    fi
    
    return "$ret";
}

################################################################################
#
#  _do_retag - Internal function to create and push tags
#
################################################################################
# Arguments:
#   1: new_tag (string) - New tag to create
#   2: current_tag (string) - Current tag for comparison
# Returns: 0 on success, 1 on failure
# Local Variables: new_tag, current_tag, note, ret

_do_retag() {
    local new_tag="$1";
    local current_tag="$2";
    local note;
    local ret=1;
    
    if [[ -z "$new_tag" ]]; then
        error "Missing new tag";
        return 1;
    fi
    
    if ! has_semver || ! is_main; then
        error "Can only retag on main branch with existing semver";
        return 1;
    fi
    
    # Check if this is actually a version increase
    if ! do_is_greater "$new_tag" "$current_tag"; then
        error "New version ($new_tag) is not greater than current ($current_tag)";
        return 1;
    fi
    
    # Check for uncommitted changes
    if ! is_not_staged; then
        if __confirm "You have uncommitted changes. Commit them with this tag"; then
            git add --all;
            git commit -m "auto: adding changes for retag @${new_tag}";
        else
            error "Cancelled due to uncommitted changes";
            return 1;
        fi
    fi
    
    # Get tag message
    note=$(__prompt "Tag message" "auto tag bump");
    
    # Create tag
    if __git_tag_create "$new_tag" "$note"; then
        info "Created tag: $new_tag";
        
        # Push tags (only if a remote exists); local tagging still succeeds
        if git remote get-url origin >/dev/null 2>&1; then
            if __git_push_tags "force"; then
                okay "Pushed tags to remote";
                # Push commits if confirmed
                if __confirm "Push commits for $new_tag and main to origin"; then
                    git push origin "$new_tag";
                    git push origin main;
                    okay "Pushed commits to remote";
                fi
                ret=0;
            else
                warn "Failed to push tags to remote; local tag created";
                ret=0;
            fi
        else
            info "No 'origin' remote configured; skipping push";
            ret=0;
        fi
    else
        error "Failed to create tag";
    fi
    
    return "$ret";
}

################################################################################
#
#  Information and Analysis Commands
#
################################################################################

################################################################################
#
#  status_data - Data-only status producer (machine-readable)
#
################################################################################
# Returns: 0 on success, 1 on failure
# Output (stdout): single-line semicolon-separated key=value pairs
# Keys: user, repo, branch, main_branch, changes, build_local, build_remote,
#       days, since, tags_last, tags_release, version_current, version_next

status_data() {
    local user branch main_branch project
    local build_local build_remote changes days since
    local tags_last tags_release
    local version_current version_next
    local pkg git calc

    if ! is_repo; then
        return 1;
    fi

    # Basics
    user=$(this_user 2>/dev/null || true)
    branch=$(this_branch 2>/dev/null || true)
    main_branch=$(which_main 2>/dev/null || true)
    project=$(this_project 2>/dev/null || true)

    # Metrics
    if has_commits; then
        build_local=$(__git_build_count 2>/dev/null || echo 0)
        build_remote=$(__git_remote_build_count 2>/dev/null || echo 0)
        changes=$(__git_status_count 2>/dev/null || echo 0)
        since=$(do_since_pretty 2>/dev/null || echo unknown)
        days=$(do_days_ago 2>/dev/null || echo 0)
    else
        build_local=0; build_remote=0; changes=0; since=unknown; days=0;
    fi

    # Tags
    tags_last=$(do_latest_semver 2>/dev/null || true)
    if git rev-parse -q --verify refs/tags/release >/dev/null 2>&1; then
        local rel_commit rel_ver rel_short
        rel_commit=$(git rev-parse release 2>/dev/null || true)
        rel_ver=$(git tag --points-at "$rel_commit" | grep -E 'v[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -n1)
        rel_short=$(git rev-parse --short "$rel_commit" 2>/dev/null || true)
        if [[ -n "$rel_ver" ]]; then
            tags_release="$rel_ver"
        else
            tags_release=""
        fi
    else
        tags_release=""
    fi

    # Versions
    if has_semver; then
        version_current=$(do_latest_semver 2>/dev/null || true)
        version_next=$(do_next_semver 0 2>/dev/null || true)
    else
        version_current=""
        version_next=""
    fi

    # Provide consolidated fields for consumers (avoid multiple data sources)
    # pkg: highest package file version if any
    local project_types
    if project_types=$(detect_project_type 2>/dev/null); then
        pkg=$(_get_package_version "$project_types" 2>/dev/null || true)
    fi
    git="$tags_last"
    calc="$version_next"

    # Emit semicolon-separated kv stream (single line)
    printf "user=%s;repo=%s;branch=%s;main_branch=%s;changes=%s;build_local=%s;build_remote=%s;days=%s;since=%s;tags_last=%s;tags_release=%s;version_current=%s;version_next=%s;pkg=%s;git=%s;calc=%s\n" \
        "$user" "$project" "$branch" "$main_branch" "$changes" "$build_local" "$build_remote" "$days" "$since" "$tags_last" "$tags_release" "$version_current" "$version_next" "$pkg" "$git" "$calc"
    return 0
}

################################################################################
#
#  do_dashboard - Show repository status dashboard
#
################################################################################
# Returns: 0 on success
# Local Variables: user, branch, main_branch, project, build, remote_build, changes, since, days, semver, next
# Stream Usage: Messages to stderr

do_dashboard() {
    local user;
    local branch;
    local main_branch;
    local project;
    local build;
    local remote_build;
    local changes;
    local changes_num;
    local since;
    local days;
    local semver;
    local next;
    local latest_tag="";
    local release_desc="";
    local msg="";
    
    # Data view passthrough
    if [[ "$(get_view_mode)" == "data" ]]; then
        status_data;
        return $?
    fi

    if ! is_repo; then
        error "Not in a git repository";
        return 1;
    fi
    
    # Gather base info via status_data for consistency
    local kd i key val data
    data=$(status_data 2>/dev/null || true)
    # Parse semicolon-separated kv pairs
    IFS=';' read -ra kd <<< "$data"
    for i in "${kd[@]}"; do
        key="${i%%=*}"; val="${i#*=}"
        case "$key" in
            user) user="$val";;
            repo) project="$val";;
            branch) branch="$val";;
            main_branch) main_branch="$val";;
            changes) changes_num="$val";;
            build_local) build="$val";;
            build_remote) remote_build="$val";;
            days) days="$val";;
            since) since="$val";;
            tags_last) latest_tag="$val";;
            tags_release) release_desc="$val";;
            version_current) semver="$val";;
            version_next) next="$val";;
        esac
    done
    
    if [[ -z "$user" ]]; then
        user="${red}-unset-${x}";
    fi
    
    if has_commits; then
        # already populated from data; ensure defaults
        build="${build:-0}"; remote_build="${remote_build:-0}";
        changes_num="${changes_num:-0}"; since="${since:-unknown}"; days="${days:-0}";
        
        # Format change count
        if [[ "$changes_num" -gt 0 ]]; then
            changes="${green}${changes_num}${x} file(s)";
        else
            changes="${grey}0${x} file(s)";
        fi
        
        # Keep numeric values for comparisons, create separate display variables
        local build_num="${build}";
        local remote_build_num="${remote_build}";
        
        # latest_tag and release_desc already populated via status_data

        # Build info message (emoji + 4-letter codes); colorize bracketed data fields
        msg+="ðŸ‘· USER: [${grey}${user}${x}]\n";
        msg+="ðŸ“¦ REPO: [${grey}${project}${x}] [${grey}${branch}${x}] [${grey}${main_branch}${x}]\n";
        # Changes: color whole bracket (green when >0, grey when 0)
        local chng_disp chng_color
        chng_disp="${changes_num} file(s)"
        if [[ "$changes_num" -gt 0 ]]; then chng_color="$green"; else chng_color="$grey"; fi
        msg+="âœï¸ CHNG: [${chng_color}${chng_disp}${x}]\n";
        # Build: color numbers by relation, keep bracket context orange
        local col_local col_remote
        if [[ "$build_num" -gt "$remote_build_num" ]]; then
            col_local="$green"; col_remote="$red";
        elif [[ "$build_num" -lt "$remote_build_num" ]]; then
            col_local="$red"; col_remote="$green";
        else
            col_local="$blue"; col_remote="$blue";
        fi
        msg+="ðŸ”§ BULD: [${grey}local=${col_local}${build_num}${x}${grey} remote=${col_remote}${remote_build_num}${x}]\n";
        # Last: color whole bracket in orange for readability; pretty string follows as-is
        msg+="â±ï¸ LAST: [${grey}${days} days${x}] ${since}\n";
        # Tags on one line: last [ ] release [ ] with colored contents
        local ltag_disp rtag_disp
        if [[ -n "$latest_tag" ]]; then
            ltag_disp="${grey}${latest_tag}${x}"
        else
            ltag_disp="${grey}-none-${x}"
        fi
        if [[ -n "$release_desc" ]]; then
            rtag_disp="${grey}${release_desc}${x}"
        else
            rtag_disp="${grey}-none-${x}"
        fi
        msg+="ðŸ·ï¸ TAGS: last [${ltag_disp}] release [${rtag_disp}]\n";
        
        # Version information (color current in grey; next colored by relation)
        if has_semver; then
            local next_raw next_disp
            next_raw="${next}"  # from status_data
            if [[ -z "$next_raw" ]]; then
                next_disp="${red}-none-${x}"
            elif [[ "$next_raw" == "$semver" ]]; then
                next_disp="${blue}${next_raw}${x}"  # same
            elif do_is_greater "$next_raw" "$semver"; then
                next_disp="${green}${next_raw}${x}" # ahead
            else
                next_disp="${orange}${next_raw}${x}" # fallback
            fi
            msg+="ðŸ”Ž VERS: [${grey}${semver}${x} -> ${next_disp}]\n";
        else
            msg+="ðŸ”Ž VERS: [${red}-unset-${x}]\n";
        fi
        
        # Enhanced: Pending Issues for Status Area
        local pending_status="";
        local pending_items=();
        
        # Check for uncommitted changes
        if [[ "$changes_num" -gt 0 ]]; then
            pending_items+=("${yellow}+ ${changes_num} changes pending commit${x}");
        fi
        
        # Check if version needs bump (calculated version ahead of current)
        if [[ -n "$next_raw" && -n "$semver" ]] && do_is_greater "$next_raw" "$semver"; then
            pending_items+=("${yellow}+ version needs bump (${semver} -> ${next_raw})${x}");
        fi
        
        # Check if version needs sync (package vs git tag mismatch)
        local package_version="";
        if [[ -n "$(detect_project_type 2>/dev/null)" ]]; then
            local project_types;
            project_types=$(detect_project_type 2>/dev/null);
            if [[ "$project_types" == *"bash"* ]]; then
                local bash_file;
                bash_file=$(get_bash_project_file 2>/dev/null);
                if [[ -n "$bash_file" && -f "$bash_file" ]]; then
                    package_version=$(__extract_version_from_file "$bash_file" 2>/dev/null);
                fi
            else
                package_version=$(_get_package_version "$project_types" 2>/dev/null);
            fi
            
            if [[ -n "$package_version" && -n "$latest_tag" ]]; then
                local git_version_clean="${latest_tag#v}";
                if [[ "$package_version" != "$git_version_clean" ]]; then
                    pending_items+=("${yellow}+ version needs sync (package: ${package_version}, git: ${latest_tag})${x}");
                fi
            fi
        fi
        
        # Add pending issues section to main content if any found
        if [[ ${#pending_items[@]} -gt 0 ]]; then
            msg+="\nâ”€â”€â”€ Pending Actions â”€â”€â”€\n";
            # Add each pending item on its own line
            local item;
            for item in "${pending_items[@]}"; do
                msg+="${item}\n";
            done
        fi
        
        # Render via enhanced dashboard view
        view_dashboard "$msg";
    else
        warn "Repository: [${user}] [${project}] [${branch}] [${red}no commits${x}]";
    fi
    
    return 0;
}

################################################################################
#
#  do_build_count - Show current build count (commit count + floor)
#
################################################################################
# Returns: 0 on success

do_build_count() {
    if ! is_repo; then
        error "Not in a git repository";
        return 1;
    fi
    __git_build_count;
    return 0;
}

################################################################################
#
#  do_mark_1 - First-time registration (baseline tag)
#
################################################################################
# Behavior:
# - If semver tags already exist: report current latest and exit 0.
# - If no tags: detect package version(s). If found, create sync tag at that version.
#   Otherwise, default to v0.0.1.
# Returns: 0 on success, 1 on failure

do_mark_1() {
    local project_types;
    local pkg_version="";
    local latest="";

    if ! is_repo; then
        error "Not in a git repository";
        return 1;
    fi

    # Already initialized?
    if has_semver; then
        latest=$(do_latest_tag);
        okay "Repository already initialized (latest: ${latest})";
        return 0;
    fi

    # Detect project types and find package version baseline (highest)
    if project_types=$(detect_project_type); then
        pkg_version=$(_get_package_version "$project_types" 2>/dev/null || true)
    fi

    if [[ -n "$pkg_version" ]]; then
        info "Initializing from package version: $pkg_version";
        if __create_sync_tag "$pkg_version"; then
            okay "Baseline created at v${pkg_version}";
            return 0;
        else
            error "Failed to create baseline sync tag at v${pkg_version}";
            return 1;
        fi
    else
        info "No package version found; defaulting to v0.0.1";
        if __git_tag_create "v0.0.1" "semv mark1: initial baseline"; then
            okay "Baseline created at v0.0.1";
            return 0;
        else
            error "Failed to create baseline tag v0.0.1";
            return 1;
        fi
    fi
}

################################################################################
#
#  do_pre_commit - Pre-commit validation gate
#
################################################################################
# Returns: 0 if validation passes, 1 if not

do_pre_commit() {
    local ret=0
    if ! is_repo; then
        error "Not in a git repository"
        return 1
    fi

    info "Running pre-commit validation..."
    if do_validate; then
        okay "Pre-commit validation passed"
        ret=0
    else
        error "Pre-commit validation failed"
        warn "Run 'semv drift' and 'semv sync' to resolve version drift"
        ret=1
    fi
    return "$ret"
}

################################################################################
#
#  do_audit - Summarize repository and version state (non-destructive)
#
################################################################################
# Returns: 0 always

do_audit() {
    local types
    local pkg_ver git_ver next_ver
    local final_result

    if ! is_repo; then
        error "Not in a git repository"
        return 1
    fi

    info "SEM V Audit Report"
    if types=$(detect_project_type); then
        info "Detected: ${types}"
        pkg_ver=$(_get_package_version "$types" 2>/dev/null || true)
    else
        warn "No supported project types detected"
    fi
    git_ver=$(_latest_tag 2>/dev/null || true)
    next_ver=$(_calculate_semv_version 2>/dev/null || true)

    # Build final result
    final_result=$(printf "\nCurrent versions:\n  Package: %s\n  Git tag: %s\n  Next:    %s\n" "${pkg_ver:-none}" "${git_ver:-none}" "${next_ver:-n/a}")

    # Output with optional boxy wrapper
    if [[ "$SEMV_USE_BOXY" == "1" ]] && command_exists boxy; then
        echo "$final_result" | boxy --theme info --title "ðŸ” Audit Report"
    else
        echo "$final_result" >&2
    fi

    # Drift analysis (info only)
    do_drift >/dev/null || true
    return 0
}

################################################################################
#
#  do_latest_remote - Show latest remote semver tag (origin)
#
################################################################################
# Returns: 0 on success, 1 on failure

do_latest_remote() {
    local out latest taglist
    if ! is_repo; then error "Not in a git repository"; return 1; fi
    info "Fetching remote tags..."
    __git_fetch_tags >/dev/null 2>&1 || true
    # Try ls-remote; fallback to local
    if out=$(git ls-remote --tags origin 2>/dev/null); then
        taglist=$(printf "%s\n" "$out" | awk '{print $2}' | sed 's@^refs/tags/@@' | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | sort -V)
        latest=$(printf "%s\n" "$taglist" | tail -1)
        if [[ -n "$latest" ]]; then printf "%s\n" "$latest"; return 0; fi
    fi
    # Fallback to local latest
    latest=$(do_latest_semver 2>/dev/null || true)
    if [[ -n "$latest" ]]; then printf "%s\n" "$latest"; return 0; fi
    return 1
}

################################################################################
#
#  do_remote_compare - Compare latest local vs remote semver tag
#
################################################################################
# Returns: 0 on success (prints comparison), 1 on failure

do_remote_compare() {
    local local latest_remote
    if ! is_repo; then error "Not in a git repository"; return 1; fi
    local=$(do_latest_semver 2>/dev/null || true)
    latest_remote=$(do_latest_remote 2>/dev/null || true)
    if [[ -z "$local" && -z "$latest_remote" ]]; then
        warn "No semver tags locally or remotely"
        return 0
    fi
    printf "Local:  %s\n" "${local:-none}" >&2
    printf "Remote: %s\n" "${latest_remote:-none}" >&2
    return 0
}

################################################################################
#
#  do_rbuild_compare - Compare local vs remote build counts
#
################################################################################
# Returns: 0 always

do_rbuild_compare() {
    local localb remoteb
    if ! is_repo; then error "Not in a git repository"; return 1; fi
    localb=$(__git_build_count)
    remoteb=$(__git_remote_build_count)
    printf "Build(local:remote) %s:%s\n" "$localb" "$remoteb" >&2
    return 0
}

################################################################################
#
#  do_pending - Show pending changes since last tag
#
################################################################################
# Arguments:
#   1: label (optional) - Commit label to filter (default: "any")
# Returns: 0 if changes found, 1 if none
# Local Variables: latest, label, changes, ret

do_pending() {
    local latest;
    local label="${1:-any}";
    local changes;
    local ret=1;
    
    if ! is_repo; then
        error "Not in a git repository";
        return 1;
    fi
    
    latest=$(do_latest_tag);
    if [[ -n "$latest" ]]; then
        if [[ "$label" != "any" ]]; then
            changes=$(git log "${latest}"..HEAD --grep="^${label}:" --pretty=format:"%h - %s");
        else
            changes=$(git log "${latest}"..HEAD --pretty=format:"%h - %s");
        fi
        
        if [[ -n "$changes" ]]; then
            warn "Found changes ($label) since $latest:";
            printf "%s\n" "$changes" >&2;
            ret=0;
        else
            okay "No labeled ($label:) commits after $latest";
            ret=1;
        fi
    else
        error "No tags found. Try 'semv new' to initialize";
        ret=1;
    fi
    
    return "$ret";
}

################################################################################
#
#  do_last - Show time since last commit
#
################################################################################
# Returns: 0 on success
# Local Variables: days, since, semver

do_last() {
    local days;
    local since;
    local semver;
    
    if ! is_repo; then
        error "Not in a git repository";
        return 1;
    fi
    
    days=$(do_days_ago);
    since=$(do_since_pretty);
    semver=$(do_latest_tag);
    
    if [[ "$days" -lt 7 ]]; then
        okay "Last commit was $since";
    elif [[ "$days" -lt 30 ]]; then
        warn "Last commit was $since";
    else
        error "Last commit was $since";
    fi
    
    return 0;
}

################################################################################
#
#  do_status - Show working directory status
#
################################################################################
# Returns: 0 if changes exist, 1 if clean
# Local Variables: count
# Outputs: Number of changed files to stdout

do_status() {
    local count;
    local final_result;
    
    if ! is_repo; then
        error "Not in a git repository";
        return 1;
    fi
    
    count=$(__git_status_count);
    final_result="$count"

    # Human-readable summary to stderr to avoid confusion with build count
    if [[ "$count" -eq 0 ]]; then
        okay "Working tree is clean"
    else
        warn "Working tree has $count changed file(s)"
    fi

    # Machine-readable count on stdout (kept for scripts)
    if [[ "$SEMV_USE_BOXY" == "1" ]] && command_exists boxy; then
        echo "$final_result" | boxy --theme info --title "ðŸ“Š Git Status Count"
    else
        echo "$final_result"
    fi

    # Exit code: 0 if changes exist, 1 if clean (legacy behavior)
    if [[ "$count" -gt 0 ]]; then
        return 0;
    else
        return 1;
    fi
}

################################################################################
#
#  Remote and Tag Management Commands
#
################################################################################

################################################################################
#
#  do_fetch_tags - Fetch tags from remote
#
################################################################################
# Returns: git fetch return code

do_fetch_tags() {
    if ! is_repo; then
        error "Not in a git repository";
        return 1;
    fi
    
    __git_fetch_tags;
}

################################################################################
#
#  do_tags - List all git tags
#
################################################################################
# Returns: 0 on success
# Local Variables: tags

do_tags() {
    local tags;
    
    if ! is_repo; then
        error "Not in a git repository";
        return 1;
    fi
    
    tags=$(__git_list_tags);
    info "Repository tags:";
    printf "%s\n" "$tags" >&2;
    
    return 0;
}

################################################################################
#
#  Development and Inspection Commands
#
################################################################################

################################################################################
#
#  do_inspect - Show available functions and dispatch mappings
#
################################################################################
# Returns: 0 always

do_inspect() {
    info "Available SEMV functions:";
    func ls "$SEMV_PATH" 2>/dev/null | grep "^do_" | sort >&2;
    
    info "";
    info "Dispatch table commands:";
    info "Version: latest, next, bump";
    info "Analysis: info, status, gs, pending, changes, since";
    info "Build: file, bc, bcr";
    info "Repo: new, can, fetch, tags";
    info "Remote: remote, upstream, rbc";
    info "Sync: get, set, sync, validate, drift";
    info "Workflow: pre-commit, release, audit";
    info "Lifecycle: install, uninstall, reset";
    info "Promotion: promote";
    info "Hooks: hook";
    info "Dev: inspect, labels, auto";
    
    return 0;
}

################################################################################
#
#  do_label_help - Show commit label conventions
#
################################################################################
# Returns: 0 always

do_label_help() {
    local msg="";
    
    msg+="~~ SEMV Commit Labels ~~\n";
    msg+="${spark} ${green}major|breaking|api:${x}   -> Major changes [Major]\n";
    msg+="${spark} ${green}feat|feature|add|minor:${x} -> Features [Minor]\n";
    msg+="${spark} ${green}fix|patch|bug|hotfix|up:${x} -> Fixes/docs [Patch]\n";
    msg+="${spark} ${green}dev:${x}                   -> Development notes [Dev Build]\n";
    
    printf "%b\n" "$msg" >&2;
    return 0;
}

################################################################################
#
#  Placeholder Commands (Future Implementation)
#
################################################################################

################################################################################
#
#  do_auto - Auto mode for external tools
#
################################################################################
# Arguments:
#   1: path (string) - Path to analyze
#   2: command (string) - Command to execute
# Returns: Command-specific return code

do_auto() {
    local action="${1:-sync}";
    shift || true;
    local ret=0;
    
    trace "Auto mode: $action";
    
    case "$action" in
        sync)
            info "Auto-sync: Running version synchronization";
            do_sync "$@";
            ret=$?;
            if [[ $ret -eq 0 ]]; then
                trace "Auto-sync completed successfully";
            else
                warn "Auto-sync completed with issues";
            fi
            ;;
        validate)
            info "Auto-validate: Running version validation";
            do_validate "$@";
            ret=$?;
            if [[ $ret -eq 0 ]]; then
                trace "Auto-validate completed successfully";
            else
                warn "Auto-validate found issues";
            fi
            ;;
        drift)
            info "Auto-drift: Running drift analysis";
            do_drift "$@";
            ret=$?;
            if [[ $ret -eq 0 ]]; then
                trace "Auto-drift completed successfully";
            else
                warn "Auto-drift found issues";
            fi
            ;;
        *)
            info "Auto mode (default): Running sync";
            do_sync "$action" "$@";
            ret=$?;
            if [[ $ret -eq 0 ]]; then
                trace "Auto-sync completed successfully";
            else
                warn "Auto-sync completed with issues";
            fi
            ;;
    esac
    
    return $ret;
}

################################################################################
#
#  do_can_semver - Check if repository is ready for semantic versioning
#
################################################################################
# Returns: 0 if ready, 1 if not ready

do_can_semver() {
    local ret=0;
    local issues=0;
    
    info "Checking semver readiness...";
    
    # Check 1: Is this a git repository?
    if ! _is_git_repo; then
        error "Not in a git repository";
        ((issues++));
    else
        okay "âœ“ Git repository detected";
    fi
    
    # Check 2: Does it have any commits?
    if ! git rev-parse HEAD >/dev/null 2>&1; then
        error "No commits found";
        ((issues++));
    else
        okay "âœ“ Repository has commits";
    fi
    
    # Check 3: Does it have semver tags?
    if has_semver; then
        okay "âœ“ Semver tags found";
    else
        warn "No semver tags found (use 'semv new' to initialize)";
    fi
    
    # Check 4: Are there uncommitted changes?
    if is_not_staged; then
        okay "âœ“ Working tree is clean";
    else
        warn "Uncommitted changes detected";
        info "Consider committing before version operations";
    fi
    
    # Check 5: Can we detect project type?
    if detect_project_type >/dev/null 2>&1; then
        okay "âœ“ Project type detected";
    else
        warn "No supported package files found";
        info "Semv will use git tags as authority";
    fi
    
    # Report results
    if [[ "$issues" -eq 0 ]]; then
        okay "Repository is ready for semantic versioning";
        ret=0;
    else
        error "Repository is not ready for semantic versioning";
        info "Fix the issues above and try again";
        ret=1;
    fi
    
    return "$ret";
}

################################################################################
#
#  do_sync - Version synchronization and conflict resolution
#
################################################################################
# Returns: 0 on success, 1 on failure
# Stream Usage: Messages to stderr

################################################################################
#
#  do_since_pretty - Pretty format for time since last commit
#
################################################################################

do_since_pretty() {
    local seconds;
    seconds=$(_seconds_since_last_commit 2>/dev/null);
    if [[ -n "$seconds" ]]; then
        _pretty_duration "$seconds";
    else
        printf "unknown";
    fi
}

################################################################################
#
#  do_days_ago - Days since last commit
#
################################################################################

do_days_ago() {
    local seconds;
    seconds=$(_seconds_since_last_commit 2>/dev/null);
    if [[ -n "$seconds" ]]; then
        printf "%d" $((seconds / 86400));
    else
        printf "0";
    fi
}

################################################################################
#
#  do_sync - Version synchronization and conflict resolution
#
################################################################################
# Returns: 0 on success, 1 on failure
# Stream Usage: Messages to stderr

################################################################################
#
#  _detect_bash_target_file - Smart bash project file detection
#
################################################################################
# Returns: Nothing (outputs file path to stdout if found)
# Local Variables: folder_name, main_script, parts_dir, build_map, first_part
# Implements STAKE-05 logic for bash project structure detection

_detect_bash_target_file() {
    local target_file;
    local pattern;
    
    trace "Detecting bash target file using intelligent pattern detection...";
    
    # Use the new intelligent detection from 08_detect.sh
    target_file=$(get_bash_project_file);
    if [[ -n "$target_file" ]]; then
        pattern=$(detect_bash_project_pattern);
        trace "Auto-detected bash target using pattern '$pattern': $target_file";
        printf "%s" "$target_file";
        return 0;
    fi
    
    # Fallback: No pattern detected
    trace "No suitable bash target file detected";
    return 1;
}

do_sync() {
    # Optional: source file to compare/sync against
    local source_file="${1:-}";
    local bash_target_file="";
    local detected_pattern="";
    local project_types="";

    info "Starting version synchronization and conflict resolution...";

    # Enhanced project type detection and target file resolution
    if [[ -z "$source_file" ]]; then
        # First, check what project types we have
        project_types=$(detect_project_type 2>/dev/null);
        
        if [[ "$project_types" == *"bash"* ]]; then
            # We have a bash project, try to get the target file
            bash_target_file=$(_detect_bash_target_file);
            if [[ -n "$bash_target_file" ]]; then
                detected_pattern=$(detect_bash_project_pattern);
                info "Auto-detected bash target file: $bash_target_file (pattern: $detected_pattern)";
                source_file="$bash_target_file";
            else
                warn "Bash project detected but no version file found";
            fi
        elif [[ "$project_types" == *"rust"* && -f "Cargo.toml" ]]; then
            # Rust project detected
            info "Auto-detected Rust project: Cargo.toml";
            source_file="Cargo.toml";
        elif [[ "$project_types" == *"javascript"* && -f "package.json" ]]; then
            # JavaScript project detected
            info "Auto-detected JavaScript project: package.json";
            source_file="package.json";
        elif [[ "$project_types" == *"python"* ]]; then
            # Python project detected - prefer pyproject.toml over setup.py
            if [[ -f "pyproject.toml" ]]; then
                info "Auto-detected Python project: pyproject.toml";
                source_file="pyproject.toml";
            elif [[ -f "setup.py" ]]; then
                info "Auto-detected Python project: setup.py";
                source_file="setup.py";
            fi
        fi
        
        # If we still don't have a source file, provide intelligent guidance
        if [[ -z "$source_file" ]]; then
            warn "Could not auto-detect version source file";
            
            # Check what's available and provide specific guidance
            if [[ -f "Cargo.toml" ]]; then
                info "Found Rust project - versions will sync automatically";
            elif [[ -f "package.json" ]]; then
                info "Found JavaScript project - versions will sync automatically";
            elif [[ -f "pyproject.toml" || -f "setup.py" ]]; then
                info "Found Python project - versions will sync automatically";
            elif [[ -f "build.sh" && -d "parts" ]]; then
                info "BashFX build.sh pattern detected:";
                info "  - Add version comment to first part file (e.g., # semv-version: 1.0.0)";
                info "  - Or specify target file: semv sync parts/01_config.sh";
            elif [[ "$(basename "$(pwd)")" == *-* ]]; then
                local suffix="${PWD##*-}";
                info "BashFX simple pattern folder detected:";
                info "  - Add version comment to ${suffix}.sh (e.g., # semv-version: 1.0.0)";
                info "  - Or specify target file: semv sync ${suffix}.sh";
            else
                info "For bash projects:";
                info "  - Add version comments to .sh files (# semv-version: 1.0.0)";
                info "  - Or use explicit file: semv sync <path-to-bash-file>";
                info "For other projects:";
                info "  - Ensure package files have version fields";
            fi
            
            error "Please specify the target file path explicitly or add version metadata";
            return 1;
        fi
    fi

    # Capture versions before sync for reporting
    local old_package_version="";
    local old_git_version="";
    local old_semv_version="";
    
    if [[ -n "$source_file" && -f "$source_file" ]]; then
        old_package_version=$(__extract_version_from_file "$source_file");
    fi
    old_git_version=$(_latest_tag);
    old_semv_version=$(_calculate_semv_version);
    
    trace "Pre-sync state: package=$old_package_version, git=$old_git_version, calculated=$old_semv_version";
    
    if resolve_version_conflicts "$source_file"; then
        # Capture versions after sync for reporting  
        local new_package_version="";
        local new_git_version="";
        local new_semv_version="";
        
        if [[ -n "$source_file" && -f "$source_file" ]]; then
            new_package_version=$(__extract_version_from_file "$source_file");
        fi
        new_git_version=$(_latest_tag);
        new_semv_version=$(_calculate_semv_version);
        
        # Show what actually changed
        local sync_summary="";
        local changes_made=0;
        
        if [[ "$old_package_version" != "$new_package_version" && -n "$new_package_version" ]]; then
            sync_summary+="ðŸ“ Package: ${old_package_version:-none} â†’ ${new_package_version}\n";
            sync_summary+="   File: ${source_file}\n";
            changes_made=1;
        fi
        
        if [[ "$old_git_version" != "$new_git_version" && -n "$new_git_version" ]]; then
            sync_summary+="ðŸ·ï¸ Git Tag: ${old_git_version:-none} â†’ ${new_git_version}\n";
            changes_made=1;
        fi
        
        if [[ "$old_semv_version" != "$new_semv_version" && -n "$new_semv_version" ]]; then
            sync_summary+="ðŸŽ¯ Next Version: ${old_semv_version:-none} â†’ ${new_semv_version}\n";
        fi
        
        # Display summary if changes were made
        if [[ "$changes_made" -eq 1 && -n "$sync_summary" ]]; then
            view "success" "ðŸ”„ Sync Summary" "$sync_summary";
        fi
        
        okay "Version synchronization completed successfully";
        return 0;
    else
        error "Version synchronization failed";
        return 1;
    fi
}

# Mark commands as loaded (load guard pattern)
readonly SEMV_COMMANDS_LOADED=1;

# === 14_hooks.sh ===
#
# 14_hooks.sh - Hook System and Tag Management
# semv-revision: 2.0.0  
# Part of SEMV - Semantic Version Manager
#

################################################################################
#
#  Auto-Retagging System
#
################################################################################

################################################################################
#
#  Tag Helpers
#
################################################################################

__tag_delete() {
    local tag="$1"
    git tag -d "$tag" 2>/dev/null && trace "Removed existing '$tag' tag" || true
}

__retag_to() {
    local tag="$1"; shift
    local version="$1"; shift
    local msg="$1"; shift || true
    local obj
    obj=$(git rev-list -n 1 "$version" 2>/dev/null) || obj=
    if [[ -z "$obj" ]]; then
        warn "Version not found for retag: $version"
        return 1
    fi
    __tag_delete "$tag"
    if git tag -a "$tag" -m "$msg" "$obj"; then
        okay "Retagged '$tag' â†’ $version"
        return 0
    fi
    error "Failed to retag '$tag' to $version"
    return 1
}

################################################################################
#
#  do_retag - Auto-retag special tags based on version state
#
################################################################################
# Arguments:
#   1: new_version - Version being tagged (e.g., v1.2.3 or v1.2.3-dev_5)
#   2: previous_version - Previous version tag
# Returns: 0 on success, 1 on failure
# Local Variables: new_version, prev_version, tag_type, ret
# Stream Usage: Messages to stderr

do_retag() {
    local new_version="$1";
    local prev_version="$2";
    local tag_type;
    local ret=1;
    
    if [[ -z "$new_version" ]]; then
        error "New version required for retagging";
        return 1;
    fi
    
    trace "Auto-retagging analysis: $new_version";
    
    # Determine version type and retag accordingly
    if [[ "$new_version" =~ -dev_ ]]; then
        tag_type="dev";
        __retag_dev "$new_version";
    elif [[ "$new_version" =~ -beta ]]; then
        tag_type="beta";
        __retag_beta "$new_version";
    elif [[ "$new_version" =~ -alpha ]]; then
        tag_type="alpha";  
        __retag_alpha "$new_version";
    else
        # Stable release
        tag_type="stable";
        __retag_stable "$new_version" "$prev_version";
    fi
    
    trace "Completed $tag_type retagging for $new_version";
    ret=0;
    return "$ret";
}

################################################################################
#
#  __retag_dev - Retag 'dev' to point to current development version
#
################################################################################
# Arguments:
#   1: dev_version - Version with dev suffix (e.g., v1.2.3-dev_5)
# Returns: 0 on success, 1 on failure

__retag_dev() {
    local dev_version="$1";
    
    info "Retagging 'dev' to point to: $dev_version";
    
    __retag_to dev "$dev_version" "semv auto-retag: current development version"
}

################################################################################
#
#  __retag_beta - Retag 'latest-dev' when exiting dev mode
#
################################################################################
# Arguments:
#   1: beta_version - Version with beta characteristics
# Returns: 0 on success, 1 on failure

__retag_beta() {
    local beta_version="$1";
    
    info "Retagging 'latest-dev' to point to: $beta_version (exited dev mode)";
    
    # Remove dev tag (no longer in dev mode)
    if git tag -d "dev" 2>/dev/null; then
        info "Removed 'dev' tag (exited dev mode)";
    fi
    
    __retag_to latest-dev "$beta_version" "semv auto-retag: latest development version"
}

################################################################################
#
#  __retag_alpha - Handle alpha version retagging
#
################################################################################
# Arguments:
#   1: alpha_version - Alpha version
# Returns: 0 on success, 1 on failure

__retag_alpha() {
    local alpha_version="$1";
    
    # Alpha versions don't auto-retag for now
    trace "Alpha version detected: $alpha_version (no auto-retag)";
    return 0;
}

################################################################################
#
#  __retag_stable - Retag stable release tags
#
################################################################################  
# Arguments:
#   1: stable_version - Stable version (e.g., v1.2.3)
#   2: prev_version - Previous version for history
# Returns: 0 on success, 1 on failure

__retag_stable() {
    local stable_version="$1";
    local prev_version="$2";
    
    info "Processing stable release: $stable_version";
    
    # Create versioned stable snapshot
    local stable_snapshot="${stable_version}-stable";
    if __retag_to "$stable_snapshot" "$stable_version" "semv stable snapshot: reversion point"; then
        okay "Created stable snapshot: $stable_snapshot";
    else
        warn "Failed to create stable snapshot tag";
    fi
    
    # Remove dev tags (no longer needed)
    if git tag -d "dev" 2>/dev/null; then
        trace "Removed 'dev' tag (stable release)";
    fi
    
    if git tag -d "latest-dev" 2>/dev/null; then
        trace "Removed 'latest-dev' tag (stable release)";
    fi
    
    # Force-retag latest to current stable version
    if ! __retag_to latest "$stable_version" "semv auto-retag: latest stable version"; then
        return 1
    fi
    
    return 0;
}

################################################################################
#
#  Manual Tag Promotion System
#
################################################################################

################################################################################
#
#  do_promote - Promote version through release channels
#
################################################################################
# Arguments:
#   1: target_channel - Channel to promote to (beta, stable, release)
#   2: version - Optional specific version to promote
# Returns: 0 on success, 1 on failure

do_promote() {
    local target_channel="$1";
    local version="${2:-}";
    local current_version;
    local ret=1;
    
    if ! require_semv_baseline; then
        return 1
    fi
    
    if [[ -z "$version" ]]; then
        current_version=$(_latest_tag);
        if [[ -z "$current_version" ]]; then
            error "No version to promote and none specified";
            return 1;
        fi
        version="$current_version";
    fi
    
    case "$target_channel" in
        beta)
            do_promote_to_beta "$version";
            ret=$?;
            ;;
        stable)
            do_promote_to_stable "$version";
            ret=$?;
            ;;
        release)
            do_promote_to_release "$version";
            ret=$?;
            ;;
        *)
            error "Unknown promotion channel: $target_channel";
            info "Supported: beta, stable, release";
            ;;
    esac
    
    return "$ret";
}

################################################################################
#
#  do_promote_to_beta - Promote dev version to beta
#
################################################################################
# Arguments:
#   1: dev_version - Version to promote from dev
# Returns: 0 on success, 1 on failure

do_promote_to_beta() {
    local dev_version="$1";
    local base_version;
    local beta_version;
    
    # Extract base version (remove dev suffix)
    base_version=$(echo "$dev_version" | sed 's/-dev_.*//')
    beta_version="${base_version}-beta";
    
    info "Promoting $dev_version to beta channel";
    
    # Confirm promotion
    if [[ "$opt_auto" -ne 0 ]]; then
        if ! __confirm "Promote $dev_version to $beta_version"; then
            error "Beta promotion cancelled";
            return 1;
        fi
    fi
    
    # Create beta tag at the resolved dev commit (not implicit HEAD)
    if __retag_to "$beta_version" "$dev_version" "semv promotion: $dev_version â†’ beta"; then
        okay "Created beta version: $beta_version";
        __retag_beta "$beta_version";
        return 0;
    else
        error "Failed to create beta tag: $beta_version";
        return 1;
    fi
}

################################################################################
#
#  do_promote_to_stable - Promote beta/dev version to stable
#
################################################################################
# Arguments:
#   1: source_version - Version to promote to stable
# Returns: 0 on success, 1 on failure

do_promote_to_stable() {
    local source_version="$1";
    local base_version;
    local stable_version;
    
    # Extract base version (remove any suffix)
    base_version=$(echo "$source_version" | sed 's/-[a-z].*//');
    stable_version="$base_version";
    
    info "Promoting $source_version to stable release";
    
    # Confirm promotion with ceremony
    warn "STABLE PROMOTION CEREMONY";
    info "Source: $source_version";  
    info "Target: $stable_version";
    info "This will create stable snapshot and retag 'latest'";
    
    if [[ "$opt_auto" -ne 0 ]]; then
        if ! __confirm "Confirm stable promotion"; then
            error "Stable promotion cancelled";
            return 1;
        fi
    fi
    
    # Create/retag stable version at the resolved commit (not implicit HEAD)
    if __retag_to "$stable_version" "$source_version" "semv promotion: $source_version â†’ stable"; then
        okay "Created stable version: $stable_version";
        __retag_stable "$stable_version" "$source_version";
        return 0;
    else
        error "Failed to create stable tag: $stable_version";
        return 1;
    fi
}

################################################################################
#
#  do_promote_to_release - Promote stable version to public release
#
################################################################################
# Arguments:
#   1: stable_version - Stable version to promote to release
# Returns: 0 on success, 1 on failure

do_promote_to_release() {
    local stable_version="$1";
    
    info "Promoting $stable_version to public release";
    
    # Check if version is actually stable
    if [[ "$stable_version" =~ -dev_|â€“beta|â€“alpha ]]; then
        warn "Promoting non-stable version to release: $stable_version";
        if [[ "$opt_auto" -ne 0 ]]; then
            if ! __confirm "Continue with non-stable release promotion"; then
                error "Release promotion cancelled";
                return 1;
            fi
        fi
    fi
    
    # Ceremonious release confirmation
    warn "PUBLIC RELEASE CEREMONY";
    info "Version: $stable_version";
    info "This will retag 'release' for public visibility";
    
    if [[ "$opt_auto" -ne 0 ]]; then
        if ! __confirm "CONFIRM PUBLIC RELEASE"; then
            error "Public release cancelled";
            return 1;
        fi
    fi
    
    # Force-retag release at the resolved commit (not implicit HEAD)
    if __retag_to "release" "$stable_version" "semv promotion: $stable_version â†’ public release"; then
        okay "Promoted to public release: $stable_version";
        return 0;
    else
        error "Failed to retag 'release' to $stable_version";
        return 1;
    fi
}

################################################################################
#
#  Hook Management System
#
################################################################################

################################################################################
#
#  do_hook - Hook management command dispatcher
#
################################################################################
# Arguments:
#   1: hook_type - Type of hook (major, minor, patch, dev)
#   2: action - Action to perform (show, set, stub, remove)
#   3: command - Hook command (for set action)
# Returns: 0 on success, 1 on failure

do_hook() {
    local hook_type="$1";
    local action="${2:-show}";
    local command="$3";
    local ret=1;
    
    case "$hook_type" in
        major|minor|patch|dev)
            case "$action" in
                show|"")
                    show_hook "$hook_type";
                    ret=$?;
                    ;;
                set)
                    if [[ -n "$command" ]]; then
                        set_hook "$hook_type" "$command";
                        ret=$?;
                    else
                        error "Command required for hook set";
                        info "Usage: semv hook $hook_type set \"./my-script.sh\"";
                    fi
                    ;;
                stub)
                    create_hook_stub "$hook_type";
                    ret=$?;
                    ;;
                remove|rm)
                    remove_hook "$hook_type";
                    ret=$?;
                    ;;
                *)
                    error "Unknown hook action: $action";
                    info "Supported: show, set, stub, remove";
                    ;;
            esac
            ;;
        *)
            error "Unknown hook type: $hook_type";
            info "Supported: major, minor, patch, dev";
            ;;
    esac
    
    return "$ret";
}

################################################################################
#
#  show_hook - Display current hook configuration
#
################################################################################
# Arguments:
#   1: hook_type - Type of hook to show
# Returns: 0 if hook exists, 1 if not configured

show_hook() {
    local hook_type="$1";
    local hook_var="SEMV_${hook_type^^}_BUMP_HOOK";
    local hook_command;
    
    # Check .semvrc first
    if [[ -f ".semvrc" ]]; then
        hook_command=$(grep "^${hook_var}=" ".semvrc" 2>/dev/null | cut -d'=' -f2 | tr -d '"'"'");
    fi
    
    if [[ -n "$hook_command" ]]; then
        info "$hook_type hook: $hook_command";
        return 0;
    else
        info "$hook_type hook: not configured";
        return 1;
    fi
}

################################################################################
#
#  set_hook - Configure hook command
#
################################################################################
# Arguments:
#   1: hook_type - Type of hook
#   2: command - Command to execute
# Returns: 0 on success, 1 on failure

set_hook() {
    local hook_type="$1";
    local command="$2";
    local hook_var="SEMV_${hook_type^^}_BUMP_HOOK";
    
    # Create or update .semvrc
    if [[ ! -f ".semvrc" ]]; then
        touch ".semvrc";
    fi
    
    # Remove existing hook setting
    if grep -q "^${hook_var}=" ".semvrc"; then
        sed -i.bak "/^${hook_var}=/d" ".semvrc";
        rm -f ".semvrc.bak" 2>/dev/null;
    fi
    
    # Add new hook setting
    echo "${hook_var}=\"${command}\"" >> ".semvrc";
    
    okay "Set $hook_type hook: $command";
    return 0;
}

################################################################################
#
#  create_hook_stub - Generate hook template script
#
################################################################################
# Arguments:
#   1: hook_type - Type of hook to create stub for
# Returns: 0 on success, 1 on failure

create_hook_stub() {
    local hook_type="$1";
    local stub_file="./hooks/${hook_type}_hook.sh";
    
    # Create hooks directory if it doesn't exist
    if [[ ! -d "./hooks" ]]; then
        mkdir -p "./hooks";
    fi
    
    # Create stub script
    cat > "$stub_file" <<EOF
#!/usr/bin/env bash
#
# SEMV $hook_type Hook - Auto-generated stub
# This script is executed after a $hook_type version bump
#

set -euo pipefail

# Hook arguments
VERSION="\$1"      # New version (e.g., v1.2.3)
PREV_VERSION="\$2" # Previous version (e.g., v1.2.2)

echo "Executing $hook_type hook for version: \$VERSION"

# Add your $hook_type bump automation here
# Examples:
# - Update documentation
# - Trigger CI/CD pipeline  
# - Send notifications
# - Update package registries
# - Run tests

echo "$hook_type hook completed successfully"
EOF
    
    chmod +x "$stub_file";
    okay "Created $hook_type hook stub: $stub_file";
    
    # Auto-configure in .semvrc
    set_hook "$hook_type" "$stub_file";
    
    return 0;
}

################################################################################
#
#  remove_hook - Remove hook configuration
#
################################################################################
# Arguments:
#   1: hook_type - Type of hook to remove
# Returns: 0 on success, 1 on failure

remove_hook() {
    local hook_type="$1";
    local hook_var="SEMV_${hook_type^^}_BUMP_HOOK";
    
    if [[ -f ".semvrc" ]]; then
        if grep -q "^${hook_var}=" ".semvrc"; then
            sed -i.bak "/^${hook_var}=/d" ".semvrc";
            rm -f ".semvrc.bak" 2>/dev/null;
            okay "Removed $hook_type hook configuration";
            return 0;
        fi
    fi
    
    warn "$hook_type hook was not configured";
    return 1;
}

################################################################################
#
#  execute_hook - Execute configured hook if present
#
################################################################################
# Arguments:
#   1: hook_type - Type of hook to execute
#   2: new_version - New version that was created
#   3: prev_version - Previous version
# Returns: 0 on success or no hook, 1 on hook failure

execute_hook() {
    local hook_type="$1";
    local new_version="$2";
    local prev_version="$3";
    local hook_var="SEMV_${hook_type^^}_BUMP_HOOK";
    local hook_command;
    
    # Check for hook configuration
    if [[ -f ".semvrc" ]]; then
        hook_command=$(grep "^${hook_var}=" ".semvrc" 2>/dev/null | cut -d'=' -f2 | tr -d '"'"'");
    fi
    
    if [[ -n "$hook_command" ]]; then
        info "Executing $hook_type hook: $hook_command";
        trace "Hook args: $new_version $prev_version";
        
        # Execute hook with version arguments
        if bash -c "$hook_command \"$new_version\" \"$prev_version\""; then
            okay "$hook_type hook completed successfully";
            return 0;
        else
            error "$hook_type hook failed";
            return 1;
        fi
    else
        trace "No $hook_type hook configured";
        return 0;
    fi
}

# === 15_dispatch.sh ===
#
# semv-dispatch.sh - Command Routing and Main Interface
# semv-revision: 2.0.0
# BashFX compliant dispatch and main functions
#

################################################################################
#
#  print_version - Show tool version from meta header
#
################################################################################
# Returns: 0 always
# Reads the first matching version meta comment near header

print_version() {
    local file="${SEMV_PATH:-${BASH_SOURCE[0]}}";
    local header;
    local line="";
    local ver="";
    local show_note="${1:-1}";  # Show explanatory note by default

    # Only search near header to avoid matching code examples later
    if [[ -r "$file" ]]; then
        header=$(head -n 120 "$file" 2>/dev/null);
        # Prefer explicit semv-version/version/app-version keys
        line=$(printf '%s\n' "$header" | grep -im1 -E '^[#;][[:space:]]*(semv-version|version|app-version)[[:space:]]*:' || true)
        if [[ -z "$line" ]]; then
            # Fallback to semv-revision if no explicit version key is present
            line=$(printf '%s\n' "$header" | grep -im1 -E '^[#;][[:space:]]*semv-revision[[:space:]]*:' || true)
        fi
    fi

    if [[ -n "$line" ]]; then
        # Strip up to colon, then trim whitespace
        ver=$(printf '%s' "$line" | sed -E 's/^[^:]*:[[:space:]]*//; s/[[:space:]]+$//');
    fi

    # Add explanatory note and professional header if requested
    if [[ "$show_note" -eq 0 ]]; then
        printf "%sLicense: Apache v2.0%s\n" "$grey2" "$x" >&2;
        printf "%sSEMV v%s - the semantic versioning powertool%s\n"  "$grey" "${ver:-unknown}" "$x" >&2;
        printf "%sCopyright (C) 2025, Qodeninja %s\n"  "$grey"  "$x" >&2;
        printf "%s (BashFX Semv) \n" "${ver:-unknown}";
    else
        printf "semv %s\n" "${ver:-unknown}";
    fi
    
    return 0;
}

################################################################################
#
#  do_project_version - Show project version (what 'info' should do now)
#
################################################################################
# Returns: Same as do_latest_semver
# Stream Usage: Project version to stdout

do_project_version() {
    # This replaces what the 'version' command used to do
    # Now 'info' shows project version, 'version' shows tool version
    do_latest_semver "$@";
}

################################################################################
#
#  do_tool_version - Show semv tool version with explanatory note
#
################################################################################
# Returns: 0 always
# Stream Usage: Tool version to stdout, note to stderr

do_tool_version() {
    # Show tool version with explanatory note (for 'version' command)
    print_version 0;  # 0 = show note
}

################################################################################
#
#  dispatch - Route commands to appropriate do_* functions
#
################################################################################
# Arguments:
#   1: command (string) - Command to execute
#   2+: args (strings) - Command arguments
# Returns: Command return code or 1 on invalid command
# Local Variables: cmd, arg, arg2, ret

dispatch() {
    local cmd="$1";
    local arg="$2";
    local arg2="$3";
    local ret=0;
    local func_name="";
    
    if [[ $# -gt 0 ]]; then shift; fi # Remove command from args if present
    
    case "$cmd" in
        # Version Operations (NEW SEMANTICS)
        ""|latest|tag)     func_name="do_latest_semver";;
        version|ver)       func_name="do_tool_version";;      # Now shows TOOL version
        next|dry)          func_name="do_next_semver";;
        bump)              func_name="do_bump";;
        
        # Project Analysis (REORGANIZED)
        info)              func_name="do_project_version";;   # Now shows PROJECT version  
        pend|pending)      func_name="do_pending";;
        chg|changes)       func_name="do_change_count";;
        since|last)        func_name="do_last";;
        st|status|stat)    func_name="do_dashboard";;          # Now shows dashboard
        gs)                func_name="do_status";;
        
        # Build Operations
        build)             func_name="do_build_file";;
        bc|build-count)    func_name="do_build_count";;
        bcr|remote-build)  func_name="do_remote_build_count";;
        
        # Repository Management
        new|mark1)         func_name="do_mark_1";;
        can)               func_name="do_can_semver";;
        fetch)             func_name="do_fetch_tags";;
        tags)              func_name="do_tags";;
        
        # Version Validation
        test)              func_name="do_test_semver";;
        comp|compare)      func_name="do_compare_versions";;
        
        # Remote Operations  
        remote)            func_name="do_latest_remote";;
        upst|upstream)     func_name="do_remote_compare";;
        rbc|remote-build-compare) func_name="do_rbuild_compare";;
        
        # Version Get/Set Commands (Phase 4A)
        get)               func_name="do_get";;
        set)               func_name="do_set";;
        
        # Sync Commands (Phase 4B)
        sync)              func_name="do_sync";;
        validate)          func_name="do_validate";;
        drift)             func_name="do_drift";;
        
        # Workflow Commands (Phase 5)
        pre-commit)        func_name="do_pre_commit";;
        release)           func_name="do_release";;
        audit)             func_name="do_audit";;
        
        # Lifecycle Commands
        install)           func_name="do_install";;
        uninstall)         func_name="do_uninstall";;
        reset)             func_name="do_reset";;
        
        # Channel Promotion Commands
        promote)           func_name="do_promote";;
        
        # Hook Management Commands
        hook)              func_name="do_hook";;
        
        # Development Commands
        inspect)           func_name="do_inspect";;
        lbl|labels)        func_name="do_label_help";;
        
        # Auto mode (for external tools)
        auto)              func_name="do_auto";;
        
        # Help
        help|\?)           func_name="usage";;
        
        *)
            if [[ -n "$cmd" ]]; then
                error "Invalid command: $cmd";
                usage;
                ret=1;
            else
                # Default behavior - show current version
                func_name="do_latest_semver";
            fi
            ;;
    esac
    
    # Execute the function if one was mapped
    if [[ -n "$func_name" ]]; then
        if function_exists "$func_name"; then
            trace "Dispatching: $cmd -> $func_name";
            # Remove first two args if present, leaving only the parameters for the command
            if [[ $# -gt 0 ]]; then shift; fi
            if [[ $# -gt 0 ]]; then shift; fi
            "$func_name" "$arg" "$arg2" "$@";
            ret=$?;
        else
            error "Function $func_name not implemented yet";
            ret=1;
        fi
    fi
    
    return "$ret";
}

################################################################################
#
#  usage - Display help information
#
################################################################################
# Returns: 0 always
# Local Variables: none

usage() {
    local help_text;
    
    printf -v help_text "%s" "
${bld}semv${x} - Semantic Version Manager

${bld}USAGE:${x}
    semv [command] [args] [flags]

${bld}VERSION OPERATIONS:${x}
    ${green}semv${x}              Show current version (default)
    ${green}version${x}           Show current version (alias)
    ${green}next${x}              Calculate next version (dry run) 
    ${green}bump${x}              Create and push new version tag
    ${green}tag${x}               Show latest semantic version tag

${bld}PROJECT ANALYSIS:${x}
    ${green}info${x}              Overall repository and version status
    ${green}status${x}            Alias of 'info' (overall status)
    ${green}st${x}                Alias of 'status'
    ${green}gs${x}                Git working tree status (# changed files)
    ${green}pend${x}              Show pending changes since last tag
    ${green}since${x}             Time since last commit

${bld}BUILD OPERATIONS:${x}
    ${green}build${x}             Generate build info file
    ${green}bc${x}                Show current build count

${bld}REMOTE:${x}
    ${green}remote${x}            Show latest remote semver tag
    ${green}upst${x}              Compare local vs remote semver
    ${green}rbc${x}               Compare local vs remote build counts

${bld}REPOSITORY MANAGEMENT:${x}
    ${green}new${x}               Initialize repo with v0.0.1
    ${green}can${x}               Check if repo can use semver
    ${green}fetch${x}             Fetch remote tags

${bld}WORKFLOW:${x}
    ${green}pre-commit${x}        Validate before committing
    ${green}audit${x}             Summarize repo/version state

${bld}VERSION GET/SET:${x}
    ${green}get all${x}           Show all detected version sources
    ${green}get rust${x}          Show Rust version (Cargo.toml)
    ${green}get js${x}            Show JavaScript version (package.json)
    ${green}get python${x}        Show Python version (pyproject.toml)
    ${green}get bash FILE${x}     Show bash script version comment
    ${green}set TYPE VER [FILE]${x} Update version in specified source

${bld}SYNCHRONIZATION:${x}
    ${green}sync [FILE]${x}       Sync using optional version source file

${bld}FLAGS:${x}
    ${yellow}-h, --help${x}         Show help and exit
    ${yellow}-d, --debug${x}        Enable debug messages
    ${yellow}-t, --trace${x}        Enable trace messages  
    ${yellow}-q, --quiet${x}        Quiet mode (errors only)
    ${yellow}-v, --version${x}      Show version and exit
    ${yellow}-f, --force${x}        Force operations
    ${yellow}-y, --yes${x}          Auto-answer yes to prompts
    ${yellow}-D, --dev${x}          Master dev flag (enables -d, -t)
    ${yellow}-N, --dev-note${x}     Add dev/build suffix to next version
    ${yellow}-B, --build-dir${x}    Set build directory for output files
        --dry-run                Dry run mode (show what would happen)
        --view=MODE              View mode: data | simple | full
        --auto / --no-auto         Automation mode (silence prompts) / restore prompts
        --no-cursor              Disable build cursor/info file generation

${bld}COMMIT LABELS:${x}
    ${orange}major|breaking|api:${x}  Major changes â†’ Major bump
    ${orange}feat|feature|add|minor:${x}  New features â†’ Minor bump
    ${orange}fix|patch|bug|hotfix|up:${x}  Fixes/docs â†’ Patch bump
    ${orange}dev:${x}                Development notes â†’ Dev build

${bld}EXAMPLES:${x}
    semv                  # Show current version
    semv bump             # Bump and tag new version
    semv info             # Show project status
    semv get all          # Show all version sources
    semv set rust 1.2.3   # Update Rust version
    semv -d pend          # Debug mode, show pending changes
";

    printf "%s\n" "$help_text" >&2;
    return 0;
}

################################################################################
#
#  main - Primary script entrypoint
#
################################################################################
# Arguments: All command-line arguments ("$@")
# Returns: Script exit code
# Local Variables: orig_args, filtered_args, ret

main() {
    local orig_args=("$@");
    local -a filtered_args;
    local ret=0;
    
    # Parse options first
    if ! options "${orig_args[@]}"; then
        error "Failed to parse options";
        return 1;
    fi

    # Fast path: help flag
    if [[ "${opt_help:-1}" -eq 0 ]]; then
        usage;
        return 0;
    fi
    
    # Fast path: version flag
    if [[ "${opt_version:-1}" -eq 0 ]]; then
        print_version 0;  # 0 = show explanatory note
        return 0;
    fi
    
    # Filter out flags to get commands/args
    mapfile -t filtered_args < <(_filter_args "${orig_args[@]}");
    
    # Basic validation
    if ! command_exists git; then
        fatal "Git is required but not found";
    fi
    
    # Dispatch to appropriate command
    dispatch "${filtered_args[@]}";
    ret=$?;
    
    return "$ret";
}

# Mark dispatch as loaded (load guard pattern)
readonly SEMV_DISPATCH_LOADED=1;

# Main execution handler (only run if script is executed, not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@";
fi


#!/usr/bin/env bash
# ┌─┐┬ ┬┌┐┌┌─┐
# ├┤ │ │││││  
# └  └─┘┘└┘└─┘
# func - Shell Function Extraction & Management Tool
# A powerful, safety-conscious utility for the FIIP workflow pattern
#
# version: 1.0.0
# author: BashFX Architecture Team
# license: GPLv3+
#
# portable: awk, sed, grep, find, mv, cp, rm, mkdir, dirname, realpath, sha256sum, md5sum
# builtins: printf, read, local, declare, case, if, for, while, test, return, exit

#===============================================================================
# BashFX Declarations  
#===============================================================================

readonly FUNC_NAME="func"
readonly FUNC_VERSION="1.0.0"
readonly FUNC_PATH="${BASH_SOURCE[0]}"
readonly FUNC_ARGS=("${@}")
readonly FUNC_PPID="$$"

# Application namespace (proper BashFX pattern)
readonly FUNC_PREF='func'

#===============================================================================
# Configuration & State
#===============================================================================

# XDG+ Compliance - use ~/.local as base
export XDG_HOME="${XDG_HOME:-$HOME/.local}"
export XDG_BIN_HOME="${XDG_BIN_HOME:-$XDG_HOME/bin}"
export XDG_LIB_HOME="${XDG_LIB_HOME:-$XDG_HOME/lib}"
export XDG_ETC_HOME="${XDG_ETC_HOME:-$XDG_HOME/etc}"
export XDG_DATA_HOME="${XDG_DATA_HOME:-$XDG_HOME/data}"
export XDG_TMP_HOME="${XDG_TMP_HOME:-$HOME/.cache/tmp}"

# Standard modes (BashFX 2.1 compliant)
DEBUG_MODE=${DEBUG_MODE:-0}  # Enable by default for better UX
QUIET_MODE=${QUIET_MODE:-1}  # Disabled by default
TRACE_MODE=${TRACE_MODE:-1}  # Disabled by default
SAFE_MODE=${SAFE_MODE:-0}    # Enabled by default

# Options state (populated by options())
opt_debug=0    # Default enabled for utility script
opt_quiet=1    # Default disabled
opt_trace=1    # Default disabled
opt_yes=1      # Default disabled
opt_force=1    # Default disabled
opt_alias=""
opt_bash=1     # Default disabled

#===============================================================================
# BashFX-Compliant Stderr System
#===============================================================================

# Color palette (respects NO_COLOR)
if [[ -z "${NO_COLOR:-}" ]]; then
    red=$'\x1B[31m'
    orange=$'\x1B[38;5;214m'
    yellow=$'\x1B[33m'
    green=$'\x1B[32m'
    blue=$'\x1B[38;5;39m'
    cyan=$'\x1B[38;5;14m'
    magenta=$'\x1B[35m'
    purple=$'\x1B[38;5;213m'
    white=$'\x1B[38;5;15m'
    grey=$'\x1B[38;5;249m'
    grey2=$'\x1B[38;5;240m'
    xx=$'\x1B[0m'
else
    red="" orange="" yellow="" green="" blue="" cyan=""
    magenta="" purple="" white="" grey="" grey2="" xx=""
fi

# Visual glyphs  
fail=$'\u2715'        # ✕
pass=$'\u2713'        # ✓
recv=$'\u27F2'        # ⟲
delta=$'\u25B3'       # △
boto=$'\u232C'        # ⌬
star=$'\xE2\x98\x85'  # ★
lambda=$'\xCE\xBB'    # λ
idots=$'\xE2\x80\xA6' # …
bolt=$'\xE2\x86\xAF'  # ↯
redo=$'\xE2\x86\xBB'  # ↻
spark=$'\u273B'       # ✻
unlock=$'\u26BF'      # ⚿

# Core printer function
__printx() {
    local text="$1" color="$2" prefix="$3" stream="${4:-2}"
    local color_code="${!color:-$white}"
    [[ -n "$text" ]] && printf "%b" "${color_code}${prefix}${text}${xx}" >&"$stream"
}

# Log dispatcher with QUIET compliance  
__log() {
    local type="$1" text="$2" force="${3:-0}" stream=2

    # Respect global quiet mode
    if [[ "$opt_quiet" -eq 0 && "$force" -eq 1 ]]; then
        [[ "$type" == "fatal" || "$type" == "error" ]] || return 0
    fi

    case "$type" in
        fatal) __printx "$text\n" "red" "$fail " "$stream"; exit 1 ;;
        error) __printx "$text\n" "red" "$fail " "$stream" ;;
        warn)  [[ $opt_debug -eq 0 ]] && __printx "$text\n" "orange" "$delta " "$stream" ;;
        okay)  [[ $opt_debug -eq 0 ]] && __printx "$text\n" "green" "$pass " "$stream" ;;
        info)  [[ $opt_debug -eq 0 ]] && __printx "$text\n" "blue" "$recv " "$stream" ;;
        trace) [[ $opt_trace -eq 0 ]] && __printx "$text\n" "grey" "$idots " "$stream" ;;
        think) [[ $opt_trace -eq 0 ]] && __printx "$text\n" "purple" "$lambda " "$stream" ;;
        lock)  __printx "$text\n" "cyan" "$unlock " "$stream" ;;
        stderr) printf "%b\n" "${text}" >&2 ;;
    esac
}

# Public interface (BashFX 2.1 compliant)
fatal() { __log fatal "$1" "1"; }
error() { __log error "$1" "1"; }  
warn()  { __log warn  "$1"; }
okay()  { __log okay  "$1"; }
info()  { __log info  "$1"; }
trace() { __log trace "$1"; }
think() { __log think "$1"; }
lock()  { __log lock  "$1"; }
stderr() { __log stderr "$1"; }

#===============================================================================
# Standard Helper Functions (Mid-Ordinal)
#===============================================================================

# Guard functions (proper BashFX naming)
is_file() { [[ -f "$1" ]]; }
is_dir() { [[ -d "$1" ]]; }
is_empty() { [[ -z "$1" ]]; }
is_dev() { [[ "$DEV_MODE" -eq 0 ]]; }

# Prompt helpers (BashFX pattern)
_prompt() {
    local prompt_msg="$1"
    local confirm
    read -p "${prompt_msg}: " confirm
    [[ "$confirm" == "y" || "$confirm" == "Y" ]]
}

_yes_prompt() {
    [[ "$opt_yes" -eq 0 ]] && return 0
    local hint="(Use --yes to skip this prompt)"
    _prompt "${1} ${hint}"
}

_force_prompt() {
    [[ "$opt_force" -eq 0 ]] && return 0  
    local hint="(Use --force to override)"
    _prompt "${1} ${hint}"
}

# Safe filesystem operations  
_safe_cp() {
    cp "$1" "$2" || fatal "Filesystem operation failed: cp '$1' to '$2'"
}

_safe_mv() {
    mv "$1" "$2" || fatal "Filesystem operation failed: mv '$1' to '$2'"  
}

_safe_rm() {
    rm "$@" || fatal "Filesystem operation failed: rm '$*'"
}

# Source validation
_is_valid_shell_source() {
    local file_path="$1"
    [[ "$opt_bash" -eq 0 ]] && return 0
    ! is_file "$file_path" && return 1
    case "$file_path" in
        (*.sh|*.bash*|*.func|*.fx) return 0 ;;
        (*.log|*.txt|*.md) return 1 ;;
    esac
    grep -q "^#!.*bash" <(head -n 1 "$file_path") && return 0
    return 1
}

#===============================================================================  
# Low-Ordinal Helper Functions (Literal Operations)
#===============================================================================

# Checksum calculation
__checksum() {
    if command -v sha256sum >/dev/null 2>&1; then
        sha256sum | awk '{print $1}'
    else
        md5sum | awk '{print $1}'
    fi
}

# Function extraction  
__extract_function_body() {
    awk -v target_func="$1" '
        BEGIN { in_func = 0; brace_level = 0; }
        $0 ~ "^[[:space:]]*" target_func "[[:space:]]*\\([[:space:]]*\\)[[:space:]]*\\{" {
            if (in_func == 0) {
                in_func = 1;
                for (i = 1; i <= length($0); ++i) { if (substr($0, i, 1) == "{") brace_level++; }
                print $0; next;
            }
        }
        in_func == 1 {
            print $0;
            for (i = 1; i <= length($0); ++i) {
                if (substr($0, i, 1) == "{") brace_level++;
                else if (substr($0, i, 1) == "}") brace_level--;
            }
            if (brace_level == 0) in_func = 0;
        }
    ' "${2}"
}

# Function location
__find_function_line() {
    grep -n -E "^[[:space:]]*${1}[[:space:]]*\([[:space:]]*\)[[:space:]]*\{" "${2}" | cut -d: -f1
}

# Metadata parsing
__parse_meta_header() {
    grep "^# FUNC_META" "$2" | sed -n "s/.*$1:\([^ |]*\).*/\1/p"
}

#===============================================================================
# Core Workflow Functions (High-Ordinal Dispatchable)  
#===============================================================================

do_copy() {
    local func_name="$1"
    local src_path="$2"
    local ret=1
    local func_body new_func_name orig_file edit_file
    
    func_body=$(__extract_function_body "$func_name" "$src_path")
    [[ -z "$func_body" ]] && fatal "Function '${func_name}' not found in '${src_path}'"

    mkdir -p "./func"
    orig_file="./func/${func_name}.orig.sh"
    
    if [[ -n "$opt_alias" ]]; then
        new_func_name="$opt_alias"
    else
        local i=2
        new_func_name="${func_name}_v${i}"
        while is_file "./func/${new_func_name}.edit.sh"; do
            i=$((i+1))
            new_func_name="${func_name}_v${i}"
        done
    fi
    edit_file="./func/${new_func_name}.edit.sh"

    if is_file "$orig_file" || is_file "$edit_file"; then
        if [[ "$opt_force" -eq 1 ]]; then
            error "Target files already exist. Use --force to overwrite"
            is_file "$orig_file" && stderr "  - Exists: $orig_file"
            is_file "$edit_file" && stderr "  - Exists: $edit_file"
            return 1
        fi
    fi
    
    printf "%s\n" "$func_body" > "$orig_file"
    echo "$func_body" | sed "1s/${func_name}/${new_func_name}/" > "$edit_file"

    local src_sum orig_sum real_src_path header
    src_sum=$(< "$src_path" __checksum)
    orig_sum=$(echo "$func_body" | __checksum)
    real_src_path=$(realpath "$src_path")
    header="# FUNC_META | src:${real_src_path} | src_sum:${src_sum} | orig:${func_name} | edit:${new_func_name} | orig_sum:${orig_sum}"
    
    sed -i "1i\\${header}" "$orig_file"
    sed -i "1i\\${header}" "$edit_file"

    okay "Created reference file: '${orig_file}'"
    okay "Created working file:   '${edit_file}'"
    ret=0
    return "$ret"
}

do_insert() {
    local new_func_name="$1"
    local src_path="$2"
    local ret=1
    local edit_file marker_pattern
    
    edit_file="./func/${new_func_name}.edit.sh"
    marker_pattern="# FUNC_INSERT ${edit_file}"

    ! is_file "$edit_file" && fatal "Function file not found: '$edit_file'"
    ! grep -q "${marker_pattern}" "$src_path" && fatal "FUNC_INSERT marker not found in '$src_path'"

    if [[ "$SAFE_MODE" -eq 0 ]]; then
        local meta_src real_src_path meta_src_sum current_src_sum
        meta_src=$(__parse_meta_header "src" "$edit_file")
        real_src_path=$(realpath "$src_path")
        if [[ "$meta_src" != "$real_src_path" ]]; then
            meta_src_sum=$(__parse_meta_header "src_sum" "$edit_file")
            current_src_sum=$(< "$src_path" __checksum)
            if [[ "$meta_src_sum" == "$current_src_sum" ]]; then
                if _yes_prompt "Warning: Source path mismatch, but checksums match. Update metadata in '${edit_file}'?"; then
                    sed -i "s|src:${meta_src}|src:${real_src_path}|" "$edit_file"
                else
                    fatal "Aborted"
                fi
            else
                fatal "SAFE_MODE: Source file path and checksum both mismatch"
            fi
        fi
    fi
    
    if is_file "${src_path}.orig"; then
        if [[ "$opt_force" -eq 0 ]]; then
            _safe_mv "${src_path}.orig" "${src_path}.orig.0"
            _safe_cp "$src_path" "${src_path}.orig"
        elif [[ "$opt_yes" -eq 1 ]]; then
            fatal "Backup file '${src_path}.orig' exists. Use --yes to proceed without backup, or --force to version existing"
        fi
    else
        _safe_cp "$src_path" "${src_path}.orig"
    fi

    sed -i -e "\\|${marker_pattern}|r ${edit_file}" -e "\\|${marker_pattern}|d" "${src_path}"
    okay "Successfully inserted '${new_func_name}' into '${src_path}'"
    ret=0
    return "$ret"
}

do_flag() {
    local func_name="$1"
    local new_func="$2" 
    local src_path="$3"
    local ret=1
    local line_num marker_text
    
    line_num=$(__find_function_line "$func_name" "$src_path")
    [[ -z "$line_num" ]] && fatal "Function '${func_name}' not found"
    
    marker_text="# FUNC_INSERT ./func/${new_func}.edit.sh"
    
    # Insert marker before the function line using a simpler approach
    {
        head -n $((line_num - 1)) "$src_path"
        echo
        echo
        echo "$marker_text"
        echo
        tail -n +$line_num "$src_path"
    } > "${src_path}.tmp" && _safe_mv "${src_path}.tmp" "${src_path}"
    
    okay "Flag for '${new_func}' inserted"
    ret=0
    return "$ret"
}

do_done() {
    local func_name="$1"
    local ret=1
    local orig_file extracted_file edit_file edit_name
    
    orig_file="./func/${func_name}.orig.sh"
    extracted_file="./func/${func_name}.extracted.sh"

    if is_file "$orig_file"; then
        edit_name=$(__parse_meta_header "edit" "$orig_file")
        [[ -n "$edit_name" ]] && edit_file="./func/${edit_name}.edit.sh"
        _safe_rm -f "$orig_file" "$edit_file"
        okay "Removed: $orig_file"
        [[ -n "$edit_file" ]] && okay "Removed: $edit_file"
        ret=0
    elif is_file "$extracted_file"; then
        _safe_rm -f "$extracted_file"
        okay "Removed: $extracted_file" 
        ret=0
    else
        fatal "No files found for '${func_name}'"
    fi
    return "$ret"
}

do_clean() {
    local ret=1
    if [[ "$opt_force" -eq 0 ]]; then
        if _force_prompt "Permanently delete ./func/ and all .orig backups?"; then
            _safe_rm -rf "./func"
            find . -maxdepth 1 -name "*.orig*" -delete
            okay "All artifacts removed"
            ret=0
        else
            warn "Clean operation cancelled"
            ret=1
        fi
    else
        if [[ -n "$(find . -maxdepth 1 -name '*.orig*' 2>/dev/null)" ]]; then
            mkdir -p "./orig"
            find . -maxdepth 1 -name "*.orig*" -exec mv -t "./orig/" {} +
            okay "Archived backups to ./orig/"
            ret=0
        else
            info "No backup files found to archive"
            ret=0
        fi
    fi
    return "$ret"
}

#===============================================================================
# Installation Functions (High-Ordinal Dispatchable - Rewindable)
#===============================================================================

do_install() {
    local ret=1
    local install_dir="${XDG_LIB_HOME}/fx/func"
    local bin_dir="${XDG_BIN_HOME}/fx"
    local script_name="func.sh"
    local link_name="func"
    local install_log="${XDG_DATA_HOME}/fx/func_install.log"
    
    # Check if already installed
    if [[ -f "$install_dir/$script_name" ]]; then
        if [[ "$opt_force" -eq 1 ]]; then
            warn "Already installed. Use --force to reinstall"
            return 1
        fi
    fi
    
    # Create directories and log creation
    mkdir -p "$install_dir" "$bin_dir" "$(dirname "$install_log")"
    
    # Log installation for rewindability
    {
        echo "# func installation log - $(date)"
        echo "INSTALL_DIR=$install_dir"
        echo "BIN_DIR=$bin_dir"
        echo "SCRIPT_NAME=$script_name" 
        echo "LINK_NAME=$link_name"
        echo "SOURCE_PATH=$FUNC_PATH"
        echo "INSTALL_TIME=$(date '+%Y-%m-%d %H:%M:%S')"
    } > "$install_log"
    
    # Copy script to lib location
    if cp "$FUNC_PATH" "$install_dir/$script_name"; then
        chmod +x "$install_dir/$script_name"
        echo "SCRIPT_INSTALLED=true" >> "$install_log"
        
        # Create symlink in bin
        if ln -sf "$install_dir/$script_name" "$bin_dir/$link_name" 2>/dev/null; then
            echo "SYMLINK_CREATED=true" >> "$install_log"
            okay "Installed to: $install_dir/$script_name"
            okay "Linked to: $bin_dir/$link_name"
            info "Add $bin_dir to your PATH to use 'func' command"
            info "Installation log: $install_log"
            ret=0
        else
            error "Failed to create symlink"
            # Cleanup partial installation
            rm -f "$install_dir/$script_name"
            ret=1
        fi
    else
        error "Failed to copy script to install location"
        ret=1
    fi
    return "$ret"
}

do_uninstall() {
    local ret=1
    local install_log="${XDG_DATA_HOME}/fx/func_install.log"
    
    # Check if installation log exists
    if [[ ! -f "$install_log" ]]; then
        warn "No installation log found. Cannot safely uninstall"
        warn "Use --force to attempt manual cleanup"
        if [[ "$opt_force" -eq 0 ]]; then
            return 1
        else
            # Manual cleanup mode
            local install_dir="${XDG_LIB_HOME}/fx/func"
            local bin_dir="${XDG_BIN_HOME}/fx"
            local link_name="func"
            local script_name="func.sh"
        fi
    else
        # Read installation log for rewindable uninstall
        source "$install_log"
    fi
    
    if [[ "$opt_force" -eq 1 ]]; then
        if ! _force_prompt "Uninstall func from XDG+ directories?"; then
            info "Uninstall cancelled"
            return 1
        fi
    fi
    
    # Remove symlink
    if [[ -L "$BIN_DIR/$LINK_NAME" ]]; then
        rm "$BIN_DIR/$LINK_NAME"
        okay "Removed symlink: $BIN_DIR/$LINK_NAME"
    fi
    
    # Remove installed script
    if [[ -f "$INSTALL_DIR/$SCRIPT_NAME" ]]; then
        rm "$INSTALL_DIR/$SCRIPT_NAME"
        okay "Removed script: $INSTALL_DIR/$SCRIPT_NAME"
    fi
    
    # Remove empty directories (following XDG+ cleanup)
    if [[ -d "$INSTALL_DIR" ]]; then
        rmdir "$INSTALL_DIR" 2>/dev/null || warn "Install directory not empty: $INSTALL_DIR"
    fi
    
    # Remove installation log
    if [[ -f "$install_log" ]]; then
        rm "$install_log"
        okay "Removed installation log"
    fi
    
    okay "Uninstall complete"
    ret=0
    return "$ret"
}

#===============================================================================
# Analysis & Utility Functions (High-Ordinal Dispatchable)
#===============================================================================

do_ls() {
    grep -E '^[[:space:]]*[a-zA-Z0-9_]+\s*\(\s*\)\s*\{' "$1" | sed -E 's/^[[:space:]]*//;s/\s*\(.*//'
}

do_spy() {
    __extract_function_body "$1" "$2"
}

do_find() {
    do_ls "$2" | grep "$1"
}

do_where() {
    local line_num
    line_num=$(__find_function_line "$1" "$2")
    [[ -z "$line_num" ]] && echo "-1" || echo "$line_num"
}

do_extract() {
    local func_name="$1"
    local func_body
    
    func_body=$(__extract_function_body "$1" "$2")
    [[ -z "$func_body" ]] && fatal "Function '${func_name}' not found"
    
    mkdir -p "./func"
    printf "%s\n" "$func_body" > "./func/${func_name}.extracted.sh"
    okay "Extracted function to './func/${func_name}.extracted.sh'"
}

do_check() {
    local orig_name="$1"
    local ret=1
    local orig_file edit_name edit_file cs1 cs2
    
    orig_file="./func/${orig_name}.orig.sh"
    ! is_file "$orig_file" && fatal "Origin file not found: '$orig_file'"
    
    edit_name=$(__parse_meta_header "edit" "$orig_file")
    edit_file="./func/${edit_name}.edit.sh"
    ! is_file "$edit_file" && fatal "Corresponding edit file not found: '$edit_file'"
    
    cs1=$(__extract_function_body "$orig_name" "$orig_file" | __checksum)
    cs2=$(__extract_function_body "$edit_name" "$edit_file" | __checksum)
    
    if [[ "$cs1" == "$cs2" ]]; then
        info "No changes detected"
        ret=1
    else
        okay "Changes detected"
        ret=0
    fi
    return "$ret"
}

do_meta() {
    local file_path="./func/${1}"
    ! is_file "$file_path" && fatal "File not found in ./func/: '$1'"
    grep "^# FUNC_META" "$file_path"
}

#===============================================================================
# Standard Interface Functions (High-Ordinal Independent)
#===============================================================================

logo() {
    cat <<-'LOGO'
	┌─┐┬ ┬┌┐┌┌─┐
	├┤ │ │││││  
	└  └─┘┘└┘└─┘
	LOGO
}

version() {
    logo
    cat << VERSION
func, version ${FUNC_VERSION} (BashFX v2.1 Utility)
Copyright (C) 2025, BashFX Architecture Team
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>

This is free software; you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

For more information, please visit github.com/qodeninja/fx-func.
VERSION
}

status() {
    logo
    local func_count orig_count
    func_count=$(ls -1 ./func/*.edit.sh 2>/dev/null | wc -l)
    orig_count=$(ls -1 ./func/*.orig.sh 2>/dev/null | wc -l)
    
    cat << STATUS
ENVIRONMENT STATUS:

Current Directory: $(pwd)
Function Directory: ${func_dir:-"./func (not created)"}
Working Files: ${func_count} edit files
Reference Files: ${orig_count} orig files  
Backup Directory: ./orig

Configuration:
  SAFE_MODE: ${SAFE_MODE}
  QUIET_MODE: ${QUIET_MODE}
  DEBUG_MODE: ${DEBUG_MODE}

Dependencies Available:
  awk: $(command -v awk >/dev/null && echo "✓" || echo "✗")
  sed: $(command -v sed >/dev/null && echo "✓" || echo "✗")
  grep: $(command -v grep >/dev/null && echo "✓" || echo "✗")

STATUS
}

usage() {
    logo
    cat << 'USAGE'
func v1.0.0 - Shell Function Extraction & Management Tool

CORE COMMANDS:
  copy <func> <src>           Extract function for editing
  insert <new_func> <src>     Insert edited function back
  flag <func> <new> <src>     Add insertion marker
  done <func_name>            Clean up artifacts
  clean                       Archive/remove all artifacts

ANALYSIS:
  ls <src>                    List functions
  spy <func> <src>            Show function body
  find <pattern> <src>        Search functions
  extract <func> <src>        Simple extraction
  check <func_name>           Compare changes

SYSTEM:
  install                     Install to system
  status                      Show environment info
  help-long                   Show detailed help
  version                     Show version

OPTIONS: -f/--force, -y/--yes, -q/--quiet, -d/--debug, --alias=<name>

USAGE
}

usage_long() {
    logo
    cat << 'USAGE'
func v1.0.0 - Shell Function Extraction & Management Tool
A powerful, safety-conscious utility for the FIIP workflow pattern.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

CORE WORKFLOW COMMANDS:

  copy <func> <src> [--alias=<new>] [-f|--force]
    Extract function from source file for editing
    → Creates .orig.sh (reference) and .edit.sh (working copy)

  insert <new_func> <src> [-y|--yes] [-f|--force]  
    Insert edited function back into source file
    → Requires FUNC_INSERT marker in source file

  flag <func> <new> <src>
    Add insertion marker to source file at function location
    → Inserts # FUNC_INSERT marker before target function

  done <func_name>
    Clean up function artifacts when development complete
    → Removes .orig.sh and corresponding .edit.sh files

  clean [-f|--force]
    Archive or permanently remove all artifacts
    → Default: moves to ./orig/  |  --force: permanent delete

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

ANALYSIS & UTILITY COMMANDS:

  ls <src> [--bash]           List all functions in source file
  spy <func> <src>            Display function body without extraction  
  find <pattern> <src>        Search for functions matching pattern
  where <func> <src>          Show line number where function is defined
  extract <func> <src>        Simple extraction without FIIP metadata
  check <func_name>           Compare original vs edited for changes
  meta <func_file>            Display metadata header for function file

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

INSTALLATION COMMANDS:

  install [-f|--force]        Install func to XDG+ lib/bin directories 
  uninstall [-f|--force]      Uninstall func (rewindable with install log)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

GLOBAL OPTIONS:

  -y, --yes          Skip confirmation prompts
  -f, --force        Override safety guards  
  -q, --quiet        Suppress stderr output
  -d, --debug        Enable verbose output messages
  -t, --trace        Enable detailed tracing output
  --alias=<name>     Custom name for copy command (BashFX pattern)
  --bash             Treat source as shell script (bypass validation)
  -h, --help         Show this help message
  --version          Show version information

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

FIIP WORKFLOW EXAMPLE:

  # 1. Analyze source file
  func ls my_script.sh

  # 2. Extract function for improvement  
  func copy calculate_total my_script.sh

  # 3. Edit the extracted function
  vim ./func/calculate_total_v2.edit.sh

  # 4. Prepare source for insertion
  func flag calculate_total calculate_total_v2 my_script.sh

  # 5. Insert improved function
  func insert calculate_total_v2 my_script.sh

  # 6. Verify and clean up
  func check calculate_total
  func done calculate_total

For more information: https://github.com/qodeninja/fx-func

USAGE
}

#===============================================================================
# BashFX 2.1 Standard Options Pattern
#===============================================================================

options() {
    local this key value opts=("${@}")
    for ((i=0; i<${#opts[@]}; i++)); do
        this=${opts[i]}
        case "$this" in
            --debug|-d)
                opt_debug=0
                opt_quiet=1
                ;;
            --trace|-t)
                opt_trace=0
                opt_debug=0
                opt_quiet=1
                ;;
            --quiet|-q)
                opt_quiet=0
                ;;
            --yes|-y)
                opt_yes=0
                ;;
            --force|-f)
                opt_force=0
                ;;
            --bash)
                opt_bash=0
                ;;
            --alias=*)
                # BashFX pattern: --flag=value
                value="${this#--alias=}"
                opt_alias="$value"
                ;;
            --help|-h)
                usage
                exit 0
                ;;
            --version)
                version
                exit 0
                ;;
            *)    
                : # Ignore unknown options
                ;;
        esac
    done
}

#===============================================================================
# Command Dispatcher (High-Ordinal Super-Function)
#===============================================================================

dispatch() {
    local command="$1"
    local src_path=""
    
    # Identify source path for validation
    case "$command" in
        (copy|flag|where|ls|find|spy|extract) src_path="${@: -1}" ;;
        (insert) src_path="$3" ;;
    esac

    if [[ -n "$src_path" ]]; then
        if ! _is_valid_shell_source "$src_path"; then
            fatal "Source file '${src_path}' does not appear to be a valid shell script. Use --bash to override"
        fi
    fi

    case "$command" in
        (copy) do_copy "$2" "$3" ;;
        (insert) do_insert "$2" "$3" ;;
        (flag) do_flag "$2" "$3" "$4" ;;
        (done) do_done "$2" ;;
        (clean) do_clean ;;
        (install) do_install ;;
        (uninstall) do_uninstall ;;
        (ls) do_ls "$2" ;;
        (spy) do_spy "$2" "$3" ;;
        (find) do_find "$2" "$3" ;;
        (where) do_where "$2" "$3" ;;
        (extract) do_extract "$2" "$3" ;;
        (check) do_check "$2" ;;
        (meta) do_meta "$2" ;;
        (status) status ;;
        (help) usage ;;
        (help-long) usage_long ;;
        (version) version ;;
        ("") usage; exit 1 ;;
        (*) fatal "Unknown command: '$command'. Use 'func help' for usage" ;;
    esac
}

#===============================================================================
# Main Function (Super-Ordinal Orchestrator)
#===============================================================================

main() {
    dispatch "${@}"
}

#===============================================================================
# BashFX 2.1 Standard Main Invocation Pattern
#===============================================================================

if [[ "$0" = "-bash" ]]; then
    :  # Script is being sourced
else
    # Direct script execution
    orig_args=("${@}")
    options "${orig_args[@]}"
    # Clean args array by removing option-like patterns  
    args=()
    for arg in "${orig_args[@]}"; do
        [[ "$arg" =~ ^-.* ]] || args+=("$arg")
    done
    main "${args[@]}"
fi
